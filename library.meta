|{
	lib=?{
		&Meta;
		lib={
			double=Library.Double_Map;
			contains=?{
				m=ObjectMap_Object(@);
				&m.ContainsKey_Map;
			}?;
			foreach=Library.Foreach_Map_Map;
			flip=func?a?b?func(b,a)???;
			containedBy=key?map?{
				m=ObjectMap_Object(
					map
				);
				&m.ContainsKey_Map(
					key
				);
			}??;
			modify=Library.Modify_Map_Map;
			sum=Number.op_Addition_Number_Number;
			power=Library.Raise_Number_Number;
			or=a?b?{
				stuff={
					1=1;
					0=b;
				};
				&stuff.<a>;
			}??;
			merge=Library.Merge_Map_Map;
			accumulate=Library.Sum_Map_Map;
			keys=arg?<"DictionaryMap_IEnumerable`1">(
				{
					m=ObjectMap_Object(arg);
					&m.get_Keys(0);
				}
			);
			product=Number.op_Multiply_Number_Number;
			not=arg?{
				stuff={
					0=1;
					1=0;
				};
				&stuff.<arg>;
			}?;
			stringToNumber=Library.StringToNumber_Map;
			parse=Parser.Parse_String;
			toString=Serialization.Serialize_Map;
			writeLine=?{
				Library.WriteLine_String(@);
				&@;
			}?;
			join=Library.Join_Map_Map;
			range=Library.Range_Number;
			reverse=Library.Reverse_Map;
			ifSingle=Library.If_Boolean_Map;
			if=Library.IfElse_Boolean_Map_Map;
			filter=Library.Filter_Map_Map;
			apply=Library.Apply_Map_Map;
			applyTo=flip(apply);
			divide=Number.op_Division_Number_Number;
			divideBy=flip(divide);
			quotient=Number.op_Division_Number_Number;
			difference=Number.op_Subtraction_Number_Number;
			differenceFrom=flip(difference);
			greater=Number.op_GreaterThan_Number_Number;
			less=Number.op_LessThan_Number_Number;
			greaterEqual=Number.op_GreaterThanOrEqual_Number_Number;
			rest=Library.Rest_Map;
			times=n?do?{
				x=rest?if(
					lessEqual(
						rest
						n
					)
					?0?
					?0?
				)?;
				x(1);
			}??;
			lessEqual=Number.op_LessThanOrEqual_Number_Number;
			vectorSum=a?b?apply(keys(a),key?sum(a.<key>,b.<key>)?)??;
			vectorLength=vector?power(
				sum(
					power(vector.1,2)
					power(vector.2,2)
				)
				1/2
			)?;
			vectorDifference=a?b?apply(
				keys(a)
				key?difference(a.<key>,b.<key>)?
			)??;
			length=arg?{
				m=ObjectMap_Object(arg);
				&m.get_ArrayCount(0);
			}?;
			select=Library.Select_Map_Map;
			slice=Library.Slice_Map_Int32_Int32;
			vectorAllLess=a?b?accumulate(
				and
				apply(
					range(length(a))
					index?less(a.<index>,b.<index>)?
				)
			)??;
			lessEqualArray=a?b?accumulate(
				and
				apply(
					range(length(a))
					index?lessEqual(a.<index>,b.<index>)?
				)
			)??;
			maximum=a?b?{
				stuff={
					1=a;
					0=b;
				};
				&stuff.<greater(a,b)>;
			}??;
			callKey=map?key?if(
				contains(map,key)
				?0?
			)??;
			minimum=a?b?{
				stuff={
					1=a;
					0=b;
				};
				&stuff.<less(a,b)>;
			}??;
			bitwiseOr=Number.op_BitwiseOr_Number_Number;
			and=a?b?{
				stuff={
					1=b;
					0=0;
				};
				&stuff.<a>;
			}??;
			andAll=accumulate(and);
			integerToString=arg?{
				m=ObjectMap_Object(arg);
				&m.ToString(0);
			}?;
			count=arg?{
				m=ObjectMap_Object(arg);
				&m.get_Count(0);
			};
			equal=Library.Equal_Object_Object;
			isNumber=arg?{
				m=ObjectMap_Object(arg);
				&m.get_IsNumber(0);
			}?;
			isString=arg?{
				m=ObjectMap_Object(arg);
				&m.get_IsString(0);
			}?;
			joinAll=Library.JoinAll_Map;
			mergeAll=Library.MergeAll_Map;
			negate=arg?difference(0,arg);
			modulo=Number.op_Modulus_Number_Number;
			vectorDotProduct=vector?number?apply(vector,entry?product(number,entry)?)??;
			productVector=a?b?apply(range(length(a)),index?product(a.<index>,b.<index>)?)??;
			print=?{
				writeLine(toString(@));
				&@;
			}?;
			printAll=applyTo(print);
			readLine=?mscorlib.Console.ReadLine(0)?;
			append=Library.Append_Map_Map;
			appendTo=flip(append);
			empty=equal(0);
			prepend=array?item?join(
				[item]
				array
			)??;
			prependTo=flip(prepend);
			switch=Library.Switch_Map_Map;
			while=Library.While_Map_Map;
			callIf=map?key?func?{
				which={
					stuff={
						0={
							|0;
						};
						1={
							|func(map.<key>);
						};
					};
					&stuff.<contains(map,key)>;
				};
				&which(0);
			}???;
			floor=Library.Floor_Number;
			filterWith=flip(filter);
			random=Library.Random_Int32_Int32;
			discard=array?func?filter(array,?not(func(@))?)??;
			mergeWith=flip(merge);
			enumerableToArray=Library.EnumerableToArray_Map;
			try=Library.Try_Map_Map;
			readTextFile=file?mscorlib.File.ReadAllText_String_Encoding(
				file,
				mscorlib.Encoding.get_Default(0)
			)?;
			compareNumber=Library.CompareNumber_Number_Number;
			sort=Library.Sort_Map_Map;
			writeTextFile=file?text?mscorlib.File.WriteAllText_String_String_Encoding(
				file
				text
				mscorlib.Encoding.get_Default(0)
			)??;
		};
	}?;
	&{
		m=lib(0);
		&m.lib;
	};
};