'"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
console=
	writeLine=
		|mscorlib.Console.WriteLine arg
	write=
		|mscorlib.Console.Write arg
	readLine=
		|mscorlib.Console.ReadLine *
integerToString=
	documentation="Converts an integer to a string."
	|
		int=Meta.Meta.Integer.[Meta.Meta.Map] arg
		this=int.ToString *
map=
	pop=
		|Meta.Meta.Library.Pop arg
	isInteger=
		|
			object=Meta.Meta.ObjectMap arg
			this=object.IsInteger.get *
	isString=
		|
			object=Meta.Meta.ObjectMap arg
			this=object.IsString.get *
	if=
		|
			argument=merge
				=
					else=
						|*
					then=
						|*
				arg
			cases=
				[1]=argument.then
				[*]=argument.else
			this=cases.[argument.condition] *
	repeat=
		documentation="Repeats an array a given number of times."
		|
			argument=arg.array
			this=join apply
				array=range arg.times
				with=
					|argument
	range=
		documentation="Returns an array containing all numbers from 1 to the argument."
		|
			array=*
			counter=1
			limit=math.add
				arg
				1
			count=
				|
					parent.parent.array.[counter]=counter
					parent.parent.counter=math.add
						counter
						1
			while
				condition=
					|math.smaller
						counter
						limit
				with=
					|
						this=count arg
			this=array
	remove=
		documentation="Removes a key from a map."
		|Meta.Meta.Library.Remove arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|
			stop=arg.condition *
			next=
				[*]=
					|*
				=
					|
						arg.with *
						while arg
			next.[stop] arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|Meta.Meta.Library.While arg
	foreach=
		|apply
			array=keys arg.map
			with=
				|arg.arg.with
					value=arg.arg.map.[arg]
					key=arg
	loop=
		|apply
			array=arg.array
			with=
				|*
	apply=
		documentation="Calls a function with every value in an array as an argument and returns the results as an array."
		|applyImplementation
			array=arg.array
			with=arg.with
			index=1
			result=*
		applyImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|applyImplementation
							array=arg.array
							with=arg.with
							index=math.add
								arg.index
								1
							object=Meta.Meta.ObjectMap arg.result
							argument=arg.with arg.array.[arg.index]
							object.Append argument
							result=object.This.get *
				this=next.[stop] arg
	join=
		documentation="Concatenates arrays."
		|Meta.Meta.Library.Join arg
	contains=
		documentation="Determines whether a map contains a key."
		|
			object=Meta.Meta.ObjectMap arg.map
			this=object.ContainsKey arg.key
	keys=
		documentation="Returns the keys of a map in an array."
		|
			object=Meta.Meta.ObjectMap arg
			this=Meta.Meta.StrategyMap.StrategyMap.[mscorlib.System.Collections.Generic.["ICollection`1"].[Meta.Meta.Map]] object.Keys.get *
	merge=
		documentation="Combines several maps into one."
		|sum
			array=arg
			with=
				|
					overwrite=arg.present
					this=sum
						array=keys arg.present
						with=
							|
								result=arg.previous
								result.[arg.present]=overwrite.[arg.present]
								this=result
						start=arg.previous
			start=*
	equal=
		documentation="Determines whether maps are identical."
		|
			result=sum
				array=arg
				with=
					|
						first=Meta.Meta.ObjectMap arg.previous.previous
						this=
							equality=logic.and
								first.Equals arg.present
								arg.previous.equality
							previous=arg.present
				start=
					equality=1
					previous=arg.[1]
			this=result.equality
	length=
		documentation="Returns the length of an array."
		|
			map=Meta.Meta.ObjectMap arg
			this=map.ArrayCount.get *
	sum=
		|sumImplementation
			index=1
			array=arg.array
			with=arg.with
			result=arg.start
		sumImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|sumImplementation
							index=math.increment arg.index
							result=arg.with
								previous=arg.result
								present=arg.array.[arg.index]
							array=arg.array
							with=arg.with
				this=next.[stop] arg
logic=
	not=
		documentation="Negates a boolean."
		|table.[arg]
		table=
			[*]=1
			[1]=*
	and=
		documentation="Returns whether all booleans are true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=1
		table=
			[
				previous=1
				present=*
			]=*
			[
				previous=*
				present=1
			]=*
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
	or=
		documentation="Returns whether at least one boolean is true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=*
		table=
			[
				previous=1
				present=*
			]=1
			[
				previous=*
				present=1
			]=1
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
math=
	increment=
		documentation="Increments an integer."
		|
			result=Meta.Meta.Integer.op_Addition
				Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg
				Meta.Meta.Integer.Integer.[Meta.Meta.Map] 1
			this=Meta.Meta.StrategyMap.StrategyMap.[Meta.Meta.Integer] result
	add=
		documentation="Adds integers."
		|Meta.Meta.StrategyMap.StrategyMap.[Meta.Meta.Integer] map.sum
			array=arg
			with=
				|Meta.Meta.Integer.op_Addition
					Meta.Meta.Integer.Integer.[Meta.Meta.Integer] arg.previous
					Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.present
			start=Meta.Meta.Integer.Integer.[Meta.Meta.Map] *
	multiply=
		documentation="Multiplies integers."
		|Meta.Meta.StrategyMap.StrategyMap.[Meta.Meta.Integer] map.sum
			array=arg
			with=
				|Meta.Meta.Integer.op_Multiply
					Meta.Meta.Integer.Integer.[Meta.Meta.Integer] arg.previous
					Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.present
			start=Meta.Meta.Integer.Integer.[Meta.Meta.Map] 1
	greater=
		documentation="Determines whether the first integer is greater than the second integer."
		|Meta.Meta.Integer.op_GreaterThan
			Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.[1]
			Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.[2]
	smaller=
		documentation="Determines whether the first integer is smaller than the second integer."
		|Meta.Meta.Integer.op_LessThan
			Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.[1]
			Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.[2]
bitwise=
	or=
		documentation="Performs a bitwise or operation on integers."
		|Meta.Meta.StrategyMap.StrategyMap.[Meta.Meta.Integer] map.sum
			array=arg
			with=
				|Meta.Meta.Integer.op_BitwiseOr
					Meta.Meta.Integer.Integer.[Meta.Meta.Integer] arg.previous
					Meta.Meta.Integer.Integer.[Meta.Meta.Map] arg.present
			start=Meta.Meta.Integer.Integer.[Meta.Meta.Map] *
string=
	lower=
		documentation="Converts a string to lowercase."
		|local.map.apply
			array=arg
			with=
				|mscorlib.Char.ToLower arg
test=
	|
		this=local.map.merge
			parent
			local.map
			local.logic
			local.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=local.bitwise.or
					8
					20
			mapTest=
				if=if
					condition=1
					then=
						|"if test successful"
				remove=remove
					map=
						x="hello"
						y="world"
					key="x"
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					this=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					this=counter
			bitwiseTest=local.bitwise.or
				20
				["System.Windows.Forms"].System.Windows.Forms.Keys.Tab
		this=test
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
path=
	combine=
		|local.map.sum
			array=arg
			with=
				|mscorlib.Path.Combine
					arg.previous
					arg.present
			start=*
directory=
	write=
		|
			argument=arg
			this=map.apply
				array=map.keys arg.files
				with=
					|
						file.write
							fileName=path.combine
								argument.directory
								arg
							text=argument.files.[arg]
debug=
	print=
		|console.writeLine Meta.Meta.FileSystem.Serialize.Value
			arg