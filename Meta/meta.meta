sdltest=
	|
		current=SdlDotNet
		ball=Sprite
			"C:\Projects\Meta\Library\Paddle2.png"
		game
			|
				screen=Video.Screen.get *
				ball.Render
					screen
				screen.Update *
				mscorlib.Console.WriteLine
					"hello world"
license='"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
game=
	|
		current=SdlDotNet
		Video.SetVideoModeWindow
			400
			300
		quit=*
		mainFunction=arg
		Events.Quit.add
			=
				|
					parent.parent.parent.quit=1
		library.map.while
			condition=
				|library.logic.not quit
			with=
				|
					Events.Poll *
					mainFunction *
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	integerToString=
		|
			int=Meta.Integer
				arg
			current=int.ToString *
	map=
		range=
			|
				array=*
				counter=1
				limit=math.add
					arg
					1
				count=
					|
						parent.parent.array.[counter]=counter
						parent.parent.counter=math.add
							counter
							1
				while
					condition=
						|math.smaller
							counter
							limit
					with=
						|
							console.writeLine counter
							current=count arg
				current=array
		remove=
			|Meta.Library.Remove
				arg
		while=
			|
				stop=arg.condition *
				next=
					[*]=
						|*
					=
						|
							arg.with *
							while arg
				next.[stop] arg
		while=
			|Meta.Library.While
				arg
		apply=
			|applyImplementation
				array=arg.array
				with=arg.with
				index=1
				result=*
			applyImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								with=arg.with
								index=math.add
									arg.index
									1
								object=Meta.ObjectMap
									arg.result
								argument=arg.with arg.array.[arg.index]
								object.Append
									argument
								result=object.Current.get *
					current=next.[stop] arg
		join=
			|Meta.Library.Join
				arg
		contains=
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			|
				object=Meta.ObjectMap
					arg
				current=Meta.StrategyMap
					object.Keys.get *
		merge=
			|sum
				array=arg
				with=
					|
						overwrite=arg.present
						current=sum
							array=keys arg.present
							with=
								|
									result=arg.previous
									result.[arg.present]=overwrite.[arg.present]
									current=result
							start=arg.previous
				start=*
		equal=
			|
				result=sum
					array=arg
					with=
						|
							first=Meta.ObjectMap
								arg.previous.previous
							current=
								equality=logic.and
									first.Equals
										arg.present
									arg.previous.equality
								previous=arg.present
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			|
				map=Meta.ObjectMap
					arg
				current=map.ArrayCount.get *
		sum=
			|sumImplementation
				index=1
				array=arg.array
				with=arg.with
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.with
									previous=arg.result
									present=arg.array.[arg.index]
								array=arg.array
								with=arg.with
					current=next.[stop] arg
	logic=
		not=
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=1
			table=
				[
					previous=1
					present=*
				]=*
				[
					previous=*
					present=1
				]=*
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
		or=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=*
			table=
				[
					previous=1
					present=*
				]=1
				[
					previous=*
					present=1
				]=1
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
	math=
		increment=
			|
				result=Meta.Integer.op_Addition
					Meta.Integer
						arg
					Meta.Integer
						1
				current=Meta.StrategyMap
					result
		increment=
			|
				result=arg
				result.[*]=arg
				current=result
		add=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
		multiply=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=1
		greater=
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
	string=
		lower=
			|library.map.apply
				array=arg
				with=
					|mscorlib.Char.ToLower
						arg
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				remove=remove
					map=
						x="hello"
						y="world"
					key="x"
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
html=
	|
		table=
			|tags.table
				text=library.map.join library.map.apply
					array=arg
					with=
						|tags.tr
							text=library.map.join library.map.apply
								array=arg
								with=
									|tags.td
										text=arg
		tags=library.map.merge library.map.apply
			with=
				|
					[arg]=
						name=arg
						|library.map.join
							"<"
							name
							argument=library.map.merge
								=
									text=*
								arg
							library.map.join library.map.apply
								array=library.map.keys library.map.remove
									map=argument
									key="text"
								with=
									|library.map.join
										" "
										arg
										"="
										'"""'
										argument.[arg]
										'"""'
							">"
							argument.text
							"</"
							name
							">"
			array=
				"html"
				"head"
				"title"
				"body"
				"h1"
				"h2"
				"h3"
				"h4"
				"h5"
				"h6"
				"p"
				"br"
				"pre"
				"b"
				"i"
				"table"
				"tr"
				"td"
				"form"
				"input"
				"a"
				"img"
				"font"
				"script"
				"div"
				"center"
displayHtml=
	|
		fileName="C:\test.html"
		file.write
			file=fileName
			text=arg
		browser fileName
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
browser=
	|process
		fileName="firefox"
		arguments=arg
path=
	|library.map.sum
		array=arg
		with=
			|mscorlib.Path.Combine
				arg.previous
				arg.present
		start=*
console=
	writeLine=
		|mscorlib.Console.WriteLine
			arg
	write=
		|mscorlib.Console.Write
			arg
	readLine=
		|mscorlib.Console.ReadLine *
website=
	|
		current=library.map.merge
			library.map
			html *
		berliosLogo=
			|table
				=
					tags.a
						href="http://developer.berlios.de"
						text=tags.img
							src="http://developer.berlios.de/bslogo.php?group_id=2780"
							width="124"
							height="32"
							border="0"
							alt="BerliOS Logo"
		websiteDirectory="C:\Projects\Meta\Website"
		indexPath=path
			websiteDirectory
			"index.html"
		script=
			|tags.script
				language="Javascript 1.2"
				type="text/javascript"
				text="
					function show(id)
					{
						el = document.getElementById(id);
						el.style.display = '';
					}
					function hide(id)
					{
						el = document.getElementById(id);
						el.style.display = 'none';
					}
					function showAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='';
						}
					}
					function hideAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='none';
						}
					}
				"
		getId=
			id=*
			|
				parent.id=library.math.increment id
				current=library.integerToString id
		items=merge apply
			array=
				"chapter"
				"example"
				"subchapter"
				"subsubchapter"
			with=
				|
					[arg]=
						typeName=arg
						|join
							argument=merge
								=
									title=typeName
									content=*
								arg
							tags.b
								text=tags.font
									size="+2"
									text=argument.title
							ids=
								item=getId *
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							names=
								item=typeName
								hideAll=join
									"hideAll"
									item
								showAll=join
									"showAll"
									item
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							tags.a
								id=ids.show
								name=names.show
								style="display:none"
								href=join
									"javascript:show('"
									ids.item
									"');hide('"
									ids.show
									"');show('"
									ids.hide
									"');"									
								text=join
									"show this "
									typeName
							tags.a
								id=ids.hide
								name=names.hide
								href=join
									"javascript:hide('"
									ids.item
									"');hide('"
									ids.hide
									"');show('"
									ids.show
									"');"
								text=join
									"hide this "
									typeName
							tags.a
								name=names.showAll
								href=join
									"javascript:showAll('"
									names.item
									"');hideAll('"
									names.showAll
									"');showAll('"
									names.hideAll
									"');hideAll('"
									names.show
									"');showAll('"
									names.hide
									"')"
								style="display:none"
								text=join
									"show all "
									typeName
									"s"
							tags.a
								name=names.hideAll
								href=join
									"javascript:hideAll('"
									names.item
									"');hideAll('"
									names.hideAll
									"');showAll('"
									names.showAll
									"');hideAll('"
									names.hide
									"');showAll('"
									names.show
									"')"
								text=join
									"hide all "
									typeName
									"s"
							tags.br *
							tags.div
								id=ids.item
								name=typeName
								text=join
									argument.content
									tags.br *
		current=merge
			parent
			items
		file.write
			fileName=indexPath
			text=tags.html 
				text=join
					tags.head 
						text=join
							script *
							tags.title
								text="Meta"
					tags.body
						text=join
							"Meta is a simple programming language."
							chapter
								title="Installation"
								content=join
									"Please download from "
									tags.a
										href="http://developer.berlios.de/project/showfiles.php?group_id=2780"
										text="here"
							chapter
								title="Language definition"
								content=join
									subchapter
										title="Select"
										content="The select expression lets you select."
									subchapter
										title="Statement"
										content="Statements asssign a value to a key."
									subchapter
										title="Call"
										content="Functions can called quite simply."
									subchapter
										title="Program"
										content="Programs create maps by executing statements."
									subchapter
										title="Function"
										content="Functions are a special type of statement, but they also create an expression."
									subchapter
										title="Literal"
										content="Literals create predefined maps."
							chapter
								title=".NET integration"
								content=join
									"Meta is implemented in C# and can directly access .NET objects and methods."
									subchapter
										title="Methods"
									subchapter
										title="Types"
									subchapter
										title="Fields"
									subchapter
										title="Properties"
									subchapter
										title="Events"
									subchapter=
										title="Conversions to Meta"
									subchapter=
										title="Conversions to .NET"
		browser indexPath
|website *
