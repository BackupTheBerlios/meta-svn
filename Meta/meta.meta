|test *
license='"
	Copyright (c) 2005 Christian Staudenmeyer

	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.

	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			writer=mscorlib.StreamWriter
				arg.file
			writer.Write
				arg.text
			writer.Close *
sdl=
	test=
		|
			current=SdlDotNet
			Video.SetVideoModeWindow
				400
				300
			quit=*
			Events.Quit.add
				=
					|
						parent.parent.parent.quit=1
			library.map.while
				condition=
					|library.logic.not quit
				with=
					|Events.Poll *
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	map=
		while=
			|
				stop=arg.condition *
				next=
					[*]=
						|*
					=
						|
							arg.with *
							while arg
				next.[stop] arg
		apply=
			|applyImplementation
				array=arg.array
				with=arg.with
				index=1
				result=*
			applyImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								with=arg.with
								index=math.add
									arg.index
									1
								object=Meta.ObjectMap
									arg.result
								argument=arg.with arg.array.[arg.index]
								object.Append
									argument
								result=object.Current.get *
					current=next.[stop] arg
		join=
			|
				result=sum
					array=arg
					with=
						|sum
							array=arg.b
							with=
								|
									map=arg.a.map
									map.[arg.a.counter]=arg.b
									counter=math.increment arg.a.counter
							start=
								map=arg.a.map
								counter=arg.a.counter
					start=
						map=*
						counter=1
				current=result.map
		contains=
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			|
				object=Meta.ObjectMap
					arg
				current=Meta.NormalMap
					object.Keys.get *
		merge=
			|sum
				array=arg
				with=
					|
						overwrite=arg.b
						current=sum
							array=keys arg.b
							with=
								|
									result=arg.a
									result.[arg.b]=overwrite.[arg.b]
									current=result
							start=arg.a
				start=*
		equal=
			|
				result=sum
					array=arg
					with=
						|
							first=Meta.ObjectMap
								arg.a.previous
							current=
								equality=logic.and
									first.Equals
										arg.b
									arg.a.equality
								previous=arg.b
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			|
				map=Meta.ObjectMap
					arg
				array=map.Array.get *
				current=array.Count.get *
		sum=
			|sumImplementation
				index=1
				array=arg.array
				with=arg.with
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.with
									a=arg.result
									b=arg.array.[arg.index]
								array=arg.array
								with=arg.with
					current=next.[stop] arg
	logic=
		not=
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=1
			table=
				[
					a=1
					b=*
				]=*
				[
					a=*
					b=1
				]=*
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
		or=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=*
			table=
				[
					a=1
					b=*
				]=1
				[
					a=*
					b=1
				]=1
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
	math=
		increment=
			|
				result=Meta.Integer.op_Addition
					Meta.Integer
						arg
					Meta.Integer
						1
				current=Meta.NormalMap
					result
		add=
			|Meta.NormalMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
		multiply=
			|Meta.NormalMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=1
		greater=
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			|Meta.NormalMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
html=
	|library.map.merge library.map.apply
		with=
			|
				[arg]=
					name=arg
					|library.map.join
						"<"
						name
						argument=library.map.merge
							=
								inner=*
								attribute=*
							arg
						library.map.join library.map.apply
							array=library.map.keys argument.attribute
							with=
								|library.map.join
									" "
									arg
									"="
									'"""'
									argument.attribute.[arg]
									'"""'
						">"
						argument.inner
						"</"
						name
						">"
		array=
			"html"
			"head"
			"title"
			"body"
			"h1"
			"h2"
			"h3"
			"h4"
			"h5"
			"h6"
			"p"
			"br"
			"pre"
			"b"
			"i"
			"table"
			"tr"
			"td"
			"form"
			"input"
ie=
	|
		file.write
			file="C:\test.html"
			text=arg
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			"iexplore.exe"
		startInfo.Arguments.set
			"C:\test.html"
		process.Start *
test=
	|
		html=html *
		ie library.map.join
			html.p
				attribute=
					align="center"
				inner=library.map.join
					html.h1
						inner="hello world"
					html.form
						inner=html.input
							inner="hello"
					html.input
						attribute=
							type="password"
							value="hello"
					html.input
						attribute=
							type="password"
							value="hello"