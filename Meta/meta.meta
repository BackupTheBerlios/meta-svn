sdltest=
	|
		current=SdlDotNet
		ball=Sprite
			"C:\Projects\Meta\Library\Paddle2.png"
		game
			|
				screen=Video.Screen.get *
				ball.Render
					screen
				screen.Update *
				mscorlib.Console.WriteLine
					"hello world"
license='"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
game=
	|
		current=SdlDotNet
		Video.SetVideoModeWindow
			400
			300
		quit=*
		mainFunction=arg
		Events.Quit.add
			=
				|
					parent.parent.parent.quit=1
		library.map.while
			condition=
				|library.logic.not quit
			with=
				|
					Events.Poll *
					mainFunction *
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	integerToString=
		documentation="Converts an integer to a string."
		|
			int=Meta.Integer
				arg
			current=int.ToString *
	map=
		repeat=
			documentation="Repeats an array a given number of times."
			|
				argument=arg.array
				current=join apply
					array=range arg.times
					with=
						|argument
		range=
			documentation="Returns an array containing all numbers from 1 to the argument."
			|
				array=*
				counter=1
				limit=math.add
					arg
					1
				count=
					|
						parent.parent.array.[counter]=counter
						parent.parent.counter=math.add
							counter
							1
				while
					condition=
						|math.smaller
							counter
							limit
					with=
						|
							current=count arg
				current=array
		remove=
			documentation="Removes a key from a map."
			|Meta.Library.Remove
				arg
		while=
			documentation="Calls a function as long as the condition function returns 1."
			|
				stop=arg.condition *
				next=
					[*]=
						|*
					=
						|
							arg.with *
							while arg
				next.[stop] arg
		while=
			documentation="Calls a function as long as the condition function returns 1."
			|Meta.Library.While
				arg
		apply=
			documentation="Calls a function with every value in an array as an argument and returns the results as an array."
			|applyImplementation
				array=arg.array
				with=arg.with
				index=1
				result=*
			applyImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								with=arg.with
								index=math.add
									arg.index
									1
								object=Meta.ObjectMap
									arg.result
								argument=arg.with arg.array.[arg.index]
								object.Append
									argument
								result=object.Current.get *
					current=next.[stop] arg
		join=
			documentation="Concatenates arrays."
			|Meta.Library.Join
				arg
		contains=
			documentation="Determines whether a map contains a key."
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			documentation="Returns the keys of a map in an array."
			|
				object=Meta.ObjectMap
					arg
				current=Meta.StrategyMap
					object.Keys.get *
		merge=
			documentation="Combines several maps into one."
			|sum
				array=arg
				with=
					|
						overwrite=arg.present
						current=sum
							array=keys arg.present
							with=
								|
									result=arg.previous
									result.[arg.present]=overwrite.[arg.present]
									current=result
							start=arg.previous
				start=*
		equal=
			documentation="Determines whether maps are identical."
			|
				result=sum
					array=arg
					with=
						|
							first=Meta.ObjectMap
								arg.previous.previous
							current=
								equality=logic.and
									first.Equals
										arg.present
									arg.previous.equality
								previous=arg.present
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			documentation="Returns the length of an array."
			|
				map=Meta.ObjectMap
					arg
				current=map.ArrayCount.get *
		sum=
			|sumImplementation
				index=1
				array=arg.array
				with=arg.with
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.with
									previous=arg.result
									present=arg.array.[arg.index]
								array=arg.array
								with=arg.with
					current=next.[stop] arg
	logic=
		not=
			documentation="Negates a boolean."
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			documentation="Returns whether all booleans are true."
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=1
			table=
				[
					previous=1
					present=*
				]=*
				[
					previous=*
					present=1
				]=*
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
		or=
			documentation="Returns whether at least one boolean is true."
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=*
			table=
				[
					previous=1
					present=*
				]=1
				[
					previous=*
					present=1
				]=1
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
	math=
		increment=
			documentation="Increments an integer."
			|
				result=Meta.Integer.op_Addition
					Meta.Integer
						arg
					Meta.Integer
						1
				current=Meta.StrategyMap
					result
		increment=
			documentation="Increments an integer."
			|
				result=arg
				result.[*]=arg
				current=result
		add=
			documentation="Adds integers."
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
		multiply=
			documentation="Multiplies integers."
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=1
		greater=
			documentation="Determines whether the first integer is greater than the second integer."
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			documentation="Determines whether the first integer is smaller than the second integer."
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			documentation="Performs a bitwise or operation on integers."
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
	string=
		lower=
			documentation="Converts a string to lowercase."
			|library.map.apply
				array=arg
				with=
					|mscorlib.Char.ToLower
						arg
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				remove=remove
					map=
						x="hello"
						y="world"
					key="x"
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
html=
	|
		table=
			|tags.table
				inner=library.map.join library.map.apply
					array=arg
					with=
						|tags.tr
							inner=library.map.join library.map.apply
								array=arg
								with=
									|tags.td
										inner=arg
		tags=library.map.merge library.map.apply
			with=
				|
					[arg]=
						name=arg
						|library.map.join
							"<"
							name
							argument=library.map.merge
								=
									inner=*
								arg
							library.map.join library.map.apply
								array=library.map.keys library.map.remove
									map=argument
									key="inner"
								with=
									|library.map.join
										" "
										arg
										"="
										'"""'
										argument.[arg]
										'"""'
							">"
							argument.inner
							"</"
							name
							">"
			array=
				"html"
				"head"
				"title"
				"body"
				"h1"
				"h2"
				"h3"
				"h4"
				"h5"
				"h6"
				"p"
				"br"
				"pre"
				"b"
				"i"
				"table"
				"tr"
				"td"
				"form"
				"input"
				"a"
				"img"
				"font"
				"script"
				"div"
				"center"
displayHtml=
	|
		fileName="C:\test.html"
		file.write
			file=fileName
			text=arg
		browser fileName
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
browser=
	|process
		fileName="firefox"
		arguments=arg
path=
	|library.map.sum
		array=arg
		with=
			|mscorlib.Path.Combine
				arg.previous
				arg.present
		start=*
console=
	writeLine=
		|mscorlib.Console.WriteLine
			arg
	write=
		|mscorlib.Console.Write
			arg
	readLine=
		|mscorlib.Console.ReadLine *
meta=
	grammar=
		emptyMap='"
			"*"
		"'
		integer='"
			("1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9") ("0"|"1"|"2"|"3"|"4"|"5"|"6"|"7"|"8"|"9")*
		"'
		character="
			<any unicode character> // insert the exact range here, maybe include it directly
		"
		string=''"
			("'")* '"' (character)+ '"' <same number of "'" as at start of string>
		"''
		program="
			indentation statement (sameIndentation statement)* dedentation
		"
		newLine="
			("\n"|"\n\r")
		"
		whitespace="
			(" "|"\t")*
		"
		sameIndentation="
			whitespace newLine <as many tabs as in previous line>
		"
		newLine='"
			("\n" | "\n\r")
		"'
		indentation="
			(<start of file> | (newLine <one tab more than in previous line>))
		"
		dedentation="
			(<end of file> | <next line has one tab less at start of line than this line>)
		"
		lookup=''"
			(~("*"|"="|"|"|"."|"'"|"\""))+ | ("[" (select|string|integer|emptyMap) "]")
		"''
		select="
			lookup ("." lookup)*
		"
		function="
			"|" expression
		"
		statement="
			( ((lookup ("." lookup)* "=")|(("=")?) ) expression) | function)
		"
		"everything that is functionally different should have its own rule
			this also makes sense from the perspective of explaining things
			"
		call="
			select (program | (" " expression))
		"
		expression="
			(emptyMap|integer|string|program|select|call)
		"
website=
	|
		current=library.map.merge
			library.map
			html *
		berliosLogo=
			|table
				=
					tags.a
						href="http://developer.berlios.de"
						inner=tags.img
							src="http://developer.berlios.de/bslogo.php?group_id=2780"
							width="124"
							height="32"
							border="0"
							alt="BerliOS Logo"
		websiteDirectory="C:\Projects\Meta\Website"
		indexPath=path
			websiteDirectory
			"index.html"
		script=
			|tags.script
				language="Javascript 1.2"
				type="text/javascript"
				inner="
					function show(id)
					{
						el = document.getElementById(id);
						el.style.display = '';
					}
					function hide(id)
					{
						el = document.getElementById(id);
						el.style.display = 'none';
					}
					function showAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='';
						}
					}
					function hideAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='none';
						}
					}
				"
		getId=
			id=*
			|
				parent.id=library.math.increment id
				current=library.integerToString id
		items=merge apply
			array=
				"chapter"
				"example"
				"subchapter"
				"subsubchapter"
			with=
				|
					[arg]=
						typeName=arg
						|join
							argument=merge
								=
									title=typeName
									content=*
								arg
							tags.div
								inner=tags.b
									inner=tags.font
										size="+1"
										inner=argument.title
							ids=
								item=getId *
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							names=
								item=typeName
								hideAll=join
									"hideAll"
									item
								showAll=join
									"showAll"
									item
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							tags.a
								id=ids.show
								style=
								name=names.show
								style="display:none"
								href=join
									"javascript:show('"
									ids.item
									"');hide('"
									ids.show
									"');show('"
									ids.hide
									"');"									
								inner=join
									"show"
							tags.a
								id=ids.hide
								name=names.hide
								href=join
									"javascript:hide('"
									ids.item
									"');hide('"
									ids.hide
									"');show('"
									ids.show
									"');"
								inner="hide"
							repeat
								array="&nbsp"
								times=8
							tags.a
								name=names.showAll
								href=join
									"javascript:showAll('"
									names.item
									"');hideAll('"
									names.showAll
									"');showAll('"
									names.hideAll
									"');hideAll('"
									names.show
									"');showAll('"
									names.hide
									"')"
								style="display:none"
								inner=join
									"show all"
							tags.a
								name=names.hideAll
								href=join
									"javascript:hideAll('"
									names.item
									"');hideAll('"
									names.hideAll
									"');showAll('"
									names.showAll
									"');hideAll('"
									names.hide
									"');showAll('"
									names.show
									"')"
								inner=join
									"hide all"
							tags.br *
							tags.div
								id=ids.item
								name=typeName
								inner=join
									argument.content
									tags.br *
		current=merge
			parent
			items
		file.write
			fileName=indexPath
			text=tags.html 
				inner=join
					tags.head 
						inner=join
							script *
							tags.title
								inner="Meta"
					tags.body
						inner=join
							"Meta is a simple programming language."
							chapter
								title="Installation"
								content=join
									"Please download from "
									tags.a
										href="http://developer.berlios.de/project/showfiles.php?group_id=2780"
										inner="here"
							chapter
								title="Language definition"
								content=join
									subchapter
										title="Select"
										content="The select expression lets you select."
									subchapter
										title="Statement"
										content="Statements asssign a value to a key."
									subchapter
										title="Call"
										content="Functions can called quite simply."
									subchapter
										title="Program"
										content="Programs create maps by executing statements."
									subchapter
										title="Function"
										content="Functions are a special type of statement, but they also create an expression."
									subchapter
										title="Literal"
										content="Literals create predefined maps."
							chapter
								title=".NET integration"
								content=join
									"Meta is implemented in C# and can directly access .NET objects and methods."
									subchapter
										title="Methods"
									subchapter
										title="Types"
									subchapter
										title="Fields"
									subchapter
										title="Properties"
									subchapter
										title="Events"
									subchapter=
										title="Conversions to Meta"
									subchapter=
										title="Conversions to .NET"
		browser indexPath
|website *
documentation=
	Miscellaneous=
		text=*
		subchapters=
			Introduction=
				text="Meta is a simple programming language."
			Installation=*
			Setup=*
	["The Meta programming language"]=
		text=*
		subchapters=
			Select=*
			Call=
				text=*
			Program=*
			Statment=*
			Function=*
			Literal=*
	[".NET integration"]=*