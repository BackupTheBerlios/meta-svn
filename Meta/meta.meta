sdltest=
	|
		current=SdlDotNet
		ball=Sprite
			"C:\Projects\Meta\Library\Paddle2.png"
		game
			|
				screen=Video.Screen.get *
				ball.Render
					screen
				screen.Update *
				mscorlib.Console.WriteLine
					"hello world"
license='"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
game=
	|
		current=SdlDotNet
		Video.SetVideoModeWindow
			400
			300
		quit=*
		mainFunction=arg
		Events.Quit.add
			=
				|
					parent.parent.parent.quit=1
		local.map.while
			condition=
				|local.logic.not quit
			with=
				|
					Events.Poll *
					mainFunction *
basicTest=
	|
		current=local.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.testClasses.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.testClasses.MemberTest
		memberTest=MemberTest *
		stringOverload=MemberTest.OverloadedMethod.[
			mscorlib.System.String
		]
			"hello"
		integerOverload=MemberTest.OverloadedMethod.[
			mscorlib.System.Int32
		]
			5
		memberTestOverload=MemberTest.OverloadedMethod.[
			MetaTest.testClasses.MemberTest
			mscorlib.System.Int32
		]
			memberTest
			3247
		memberTestOverload=MemberTest.OverloadedMethod.[
			MetaTest.testClasses.MemberTest
			mscorlib.System.Int32
		]
			memberTest
			3247
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.testClasses.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.testClasses.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.testClasses.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=local.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].System.Drawing.Font.Font.[
			mscorlib.System.String
			mscorlib.System.Single
		]
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.System.Collections.ArrayList.ArrayList.[*] *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].System.Windows.Forms.TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue.[
			mscorlib.System.Int32
		]
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=local.logic.not local.map.equal
					arg
					10
				whileBranches=
					=
						|loop local.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
console=
	writeLine=
		|mscorlib.Console.WriteLine
			arg
	write=
		|mscorlib.Console.Write
			arg
	readLine=
		|mscorlib.Console.ReadLine *
integerToString=
	documentation="Converts an integer to a string."
	|
		int=Meta.Meta.Integer.[
			Meta.Meta.Map
		]
			arg
		current=int.ToString *
map=
	pop=
		|Meta.Meta.Library.Pop
			arg
	isInteger=
		|
			object=Meta.Meta.ObjectMap
				arg
			current=object.IsInteger.get *
	isString=
		|
			object=Meta.Meta.ObjectMap
				arg
			current=object.IsString.get *
	if=
		|
			argument=merge
				=
					else=
						|*
					then=
						|*
				arg
			cases=
				[1]=argument.then
				[*]=argument.else
			current=cases.[argument.condition] *
	repeat=
		documentation="Repeats an array a given number of times."
		|
			argument=arg.array
			current=join apply
				array=range arg.times
				with=
					|argument
	range=
		documentation="Returns an array containing all numbers from 1 to the argument."
		|
			array=*
			counter=1
			limit=math.add
				arg
				1
			count=
				|
					parent.parent.array.[counter]=counter
					parent.parent.counter=math.add
						counter
						1
			while
				condition=
					|math.smaller
						counter
						limit
				with=
					|
						current=count arg
			current=array
	remove=
		documentation="Removes a key from a map."
		|Meta.Meta.Library.Remove
			arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|
			stop=arg.condition *
			next=
				[*]=
					|*
				=
					|
						arg.with *
						while arg
			next.[stop] arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|Meta.Meta.Library.While
			arg
	foreach=
		|apply
			array=keys arg.map
			with=
				|arg.arg.with
					value=arg.arg.map.[arg]
					key=arg
	loop=
		|apply
			array=arg.array
			with=
				|*
	apply=
		documentation="Calls a function with every value in an array as an argument and returns the results as an array."
		|applyImplementation
			array=arg.array
			with=arg.with
			index=1
			result=*
		applyImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|applyImplementation
							array=arg.array
							with=arg.with
							index=math.add
								arg.index
								1
							object=Meta.Meta.ObjectMap
								arg.result
							argument=arg.with arg.array.[arg.index]
							object.Append
								argument
							result=object.Current.get *
				current=next.[stop] arg
	join=
		documentation="Concatenates arrays."
		|Meta.Meta.Library.Join
			arg
	contains=
		documentation="Determines whether a map contains a key."
		|
			object=Meta.Meta.ObjectMap
				arg.map
			current=object.ContainsKey
				arg.key
	keys=
		documentation="Returns the keys of a map in an array."
		|
			object=Meta.Meta.ObjectMap
				arg
			current=Meta.Meta.StrategyMap.StrategyMap.[
				mscorlib.System.Collections.ICollection
			]				
				object.Keys.get *
	merge=
		documentation="Combines several maps into one."
		|sum
			array=arg
			with=
				|
					overwrite=arg.present
					current=sum
						array=keys arg.present
						with=
							|
								result=arg.previous
								result.[arg.present]=overwrite.[arg.present]
								current=result
						start=arg.previous
			start=*
	equal=
		documentation="Determines whether maps are identical."
		|
			result=sum
				array=arg
				with=
					|
						first=Meta.Meta.ObjectMap
							arg.previous.previous
						current=
							equality=logic.and
								first.Equals
									arg.present
								arg.previous.equality
							previous=arg.present
				start=
					equality=1
					previous=arg.[1]
			current=result.equality
	length=
		documentation="Returns the length of an array."
		|
			map=Meta.Meta.ObjectMap
				arg
			current=map.ArrayCount.get *
	sum=
		|sumImplementation
			index=1
			array=arg.array
			with=arg.with
			result=arg.start
		sumImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|sumImplementation
							index=math.increment arg.index
							result=arg.with
								previous=arg.result
								present=arg.array.[arg.index]
							array=arg.array
							with=arg.with
				current=next.[stop] arg
logic=
	not=
		documentation="Negates a boolean."
		|table.[arg]
		table=
			[*]=1
			[1]=*
	and=
		documentation="Returns whether all booleans are true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=1
		table=
			[
				previous=1
				present=*
			]=*
			[
				previous=*
				present=1
			]=*
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
	or=
		documentation="Returns whether at least one boolean is true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=*
		table=
			[
				previous=1
				present=*
			]=1
			[
				previous=*
				present=1
			]=1
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
math=
	increment=
		documentation="Increments an integer."
		|
			result=Meta.Meta.Integer.op_Addition
				Meta.Meta.Integer.Integer.[
					Meta.Meta.Map
				]
					arg
				Meta.Meta.Integer.Integer.[	
					Meta.Meta.Map
				]
					1
			current=Meta.Meta.StrategyMap.StrategyMap.[
				Meta.Meta.Integer
			]
				result
	add=
		documentation="Adds integers."
		|Meta.Meta.StrategyMap.StrategyMap.[
			Meta.Meta.Integer
		]
			map.sum
				array=arg
				with=
					|Meta.Meta.Integer.op_Addition
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Integer
						]
							arg.previous
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Map
						]
							arg.present
				start=Meta.Meta.Integer.Integer.[
					Meta.Meta.Map
				]
					*
	multiply=
		documentation="Multiplies integers."
		|Meta.Meta.StrategyMap.StrategyMap.[
			Meta.Meta.Integer
		]
			map.sum
				array=arg
				with=
					|Meta.Meta.Integer.op_Multiply
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Integer
						]
							arg.previous
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Map
						]
							arg.present
				start=Meta.Meta.Integer.Integer.[
					Meta.Meta.Map
				]
					1
	greater=
		documentation="Determines whether the first integer is greater than the second integer."
		|Meta.Meta.Integer.op_GreaterThan
			Meta.Meta.Integer.Integer.[
				Meta.Meta.Map
			]
				arg.[1]
			Meta.Meta.Integer.Integer.[
				Meta.Meta.Map
			]
				arg.[2]
	smaller=
		documentation="Determines whether the first integer is smaller than the second integer."
		|Meta.Meta.Integer.op_LessThan
			Meta.Meta.Integer.Integer.[
				Meta.Meta.Map
			]
				arg.[1]
			Meta.Meta.Integer.Integer.[
				Meta.Meta.Map
			]
				arg.[2]
bitwise=
	or=
		documentation="Performs a bitwise or operation on integers."
		|Meta.Meta.StrategyMap.StrategyMap.[
			Meta.Meta.Integer
		]
			map.sum
				array=arg
				with=
					|Meta.Meta.Integer.op_BitwiseOr
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Integer
						]
							arg.previous
						Meta.Meta.Integer.Integer.[
							Meta.Meta.Map
						]
							arg.present
				start=Meta.Meta.Integer.Integer.[
					Meta.Meta.Map
				]
					*
string=
	lower=
		documentation="Converts a string to lowercase."
		|local.map.apply
			array=arg
			with=
				|mscorlib.Char.ToLower
					arg
libraryTest=
	|
		current=local.map.merge
			parent
			local.map
			local.logic
			local.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=local.bitwise.or
					8
					20
			mapTest=
				if=if
					condition=1
					then=
						|"if test successful"
				remove=remove
					map=
						x="hello"
						y="world"
					key="x"
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=local.bitwise.or
				20
				["System.Windows.Forms"].System.Windows.Forms.Keys.Tab
		current=test
html=
	tags=
		"link"
		"html"
		"head"
		"title"
		"body"
		"h1"
		"h2"
		"h3"
		"h4"
		"h5"
		"h6"
		"p"
		"br"
		"pre"
		"b"
		"i"
		"table"
		"tr"
		"td"
		"form"
		"input"
		"a"
		"img"
		"font"
		"script"
		"div"
		"center"
		"frame"
		"frameset"
	|local.map.merge local.map.apply
		with=
			|
				[arg]=
					name=arg
					|local.map.join
						"<"
						name
						argument=arg
						local.map.join local.map.apply
							array=local.map.keys local.map.remove
								map=argument
								key="inner"
							with=
								|map.if
									condition=logic.not map.isInteger arg
									then=
										|local.map.join
											" "
											arg.arg
											"="
											'"""'
											argument.[arg.arg]
											'"""'
						">"
						map.join arg
						"</"
						name
						">"
		array=tags
displayHtml=
	|
		fileName="C:\test.html"
		file.write
			fileName=fileName
			text=arg
		browser fileName
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
browser=
	|process
		fileName="firefox"
		arguments=arg
path=
	combine=
		|local.map.sum
			array=arg
			with=
				|mscorlib.Path.Combine
					arg.previous
					arg.present
			start=*
meta=
	=
		title="Introduction"
		explanation="Meta is a small programming language that is designed to be kept in the
			programmer's head all at once."
	=
		title="Tutorial"
		introduction="This small tutorial is supposed to guide you through most of Meta's
			functionality with a few examples."
		chapters=*
	=
		title=".NET"
		introduction="This part explains how the integration of Meta with .NET works."
		chapters=
			Objects=*
			Classes=*
			Enumerations=*
			Delegates=*
			Events=*
			Properties=*
			Indexers=*
			Methods=*
	=
		title="Language"
		introduction="This part defines the Meta programming language itself."
		chapters=
			=
				title="Maps"
				explanation="Maps are the foundation of Meta. They are the only data type
					that exists in Meta. Most programming languages use several or even many
					different data types. Often, data types only exist in the form of
					libraries and the only way to build abstractions of data is using
					a builtin concept of 'classes' or something like this. The reason there
					are usually several data types is efficiency. Maps are more general than
					arrays, for example. Most programming languages, however make both 
					avaiblable, however, even though the interface of a map is more general
					than that of an array. It is thus possible in these languages to
					tell the interpreter or compiler which implementation strategy you
					want to use. If you are willing to take some restrictions, the
					performance will be better. The program structure will not be any
					simpler, though. 
					Likewise, many programming languages use things like 'objects',
					local variable scope, global variable scope, function parameters and
					so on as a way to support a restricted form of the map interface.
					By creating a different concept for every case where something map-like
					is called for, these concepts can be implemented efficiently very easily.
					Meta cannot be implemented efficiently very easily, however it can
					be implemented as efficiently as those other programming languages,
					although it is a bit more effort. On the other hand, implementing it
					somewhat inefficient is much easier than implementing any of those other
					programming languages at all.
					
					Meta makes programming much easier by using one and the same interface
					for all these cases. This also allows much more flexibility, because
					most programming language designers did not think of all the things
					programmers would want to do with their language. Since they did not 
					think of it, they could not optimize it, so it is not included in the
					language. In Meta, it might not be optimized, but it is possible.
					Being so general, Meta is also much more concise and easier to read
					and unserstand. Meta cleanly separates the design, or interface, from
					the implementation."
			=
				title="Creating empty maps"
				tutorial="There is not really much you can with just an empty map.
					Every empty map is exactly the same as all the others"
				explanation="Evaluates to a map containing zero key-value pairs."
				grammar='"
					'*'
				"'
				code="
					literal=*
					"
			=
				title="Selecting values"
				explanation="Evaluates to the value of the last lookup. The first lookup
					searches its key in the current scope if necessary. Subsequent lookups
					look up their keys in the previous result without searching.
				"
				grammar="
					lookup ('.' lookup)*
				"
				code="
					select=
						[1]=<expression>
						[2]=<expression>
						[3]=<expression>
						...
					"
			=
				title="Creating integers"
				explanation="Evaluates to a map representing the given integer. The map
					is as deep as the number it represents."
				grammar='"
					('1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9') ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')*
				"'
				code="
					literal=2342
					"
			=
				title="Creating strings"
				explanation="Evaluates to an array containing the provided unicode characters
					in the form of integers."
				grammar=''"
					'''* '"' <any unicode character>+ '"' '''* {same number of ''' as at start of string}
				code="
					literal="string"
					"
					"''
			=
				title="Creating maps"
				grammar="
					indentation statement (sameIndentation statement)* dedentation
				"
				explanation="Evaluates to the map that results from executing all statements
					in a map that is initially empty."
				subGrammar=
					NewLine="
						('\n'|'\n\r')
					"
					Whitespace="
						(' '|'\t')*
					"
					SameIndentation="
						whitespace newLine <as many tabs as in previous line>
					"
					Indentation="
						(<start of file> | (newLine <one tab more than in previous line>))
					"
					Dedentation="
						(<end of file> | <next line has one tab less at start of line than this line>)
					"
				code="
					program=
						[1]=<statement>
						[2]=<statement>
						[3]=<statement>
						...
					"
			=
				title="Assigning values to keys"
				explanaton="Assigns the result from an expression to a key."
				grammar="
					( ( (lookup ('.' lookup)*)? '=')? expression) | function
				"
				code="
					key=
						[1]=<expression>
						[2]=<expression>
						[1]=<expression>
					value=<expression>
					"
			=
				title="Looking up values"
				explanation="Is a syntactical element used both in statements and in
					select expressions."
				grammar=''"
					(any unicode character except: '*','=','|','.','"',''','[',']') + 
					| ("[" (select|string|integer|emptyMap) "]")
				"''
			=
				title="Creating functions"
				explanation="Assigns the code-equivalent of 'expression' to the key 'function'
					in the current map."
				grammar="
					'|' expression
				"
				code='"
					key=
						[1]="function"
					value=<expression>
					"'
			=
				title="Calling functions"
				explanation="Evaluates to the return value from calling the 'select' with an expression
					as the argument."
				grammar="
					select ' '? expression
				"
				code="
					callable=<select>
					argument=<expression>
					"
			=
				title="Creating values"
				explanation="Anything that returns a value is an expression."
				grammar="
					emptyMap|integer|string|program|select|call
				"
website=
	|
		current=local.map.merge
			local.map
			html *
		berliosLogo=
			|table
				=
					tags.a
						href="http://developer.berlios.de"
						tags.img
							src="http://developer.berlios.de/bslogo.php?group_id=2780"
							width="124"
							height="32"
							border="0"
							alt="BerliOS Logo"
		websiteDirectory="C:\Projects\Meta\Website"
		indexPath=path
			websiteDirectory
			"index.html"
		script=
			|tags.script
				language="Javascript 1.2"
				type="text/javascript"
				"
					function show(id)
					{
						el = document.getElementById(id);
						el.style.display = '';
					}
					function hide(id)
					{
						el = document.getElementById(id);
						el.style.display = 'none';
					}
					function showAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='';
						}
					}
					function hideAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='none';
						}
					}
				"
		getId=
			id=*
			|
				parent.id=local.math.increment id
				current=local.integerToString id
		items=merge apply
			array=
				"chapter"
				"example"
				"subchapter"
				"subsubchapter"
			with=
				|
					[arg]=
						typeName=arg
						|join
							argument=merge
								=
									title=typeName
									content=*
								arg
							tags.div
								tags.b
									tags.font
										size="+1"
										argument.title
							ids=
								item=getId *
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							names=
								item=typeName
								hideAll=join
									"hideAll"
									item
								showAll=join
									"showAll"
									item
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							tags.a
								id=ids.show
								style=""
								name=names.show
								style="display:none"
								href=join
									"javascript:show('"
									ids.item
									"');hide('"
									ids.show
									"');show('"
									ids.hide
									"');"									
								"show"
							tags.a
								id=ids.hide
								name=names.hide
								href=join
									"javascript:hide('"
									ids.item
									"');hide('"
									ids.hide
									"');show('"
									ids.show
									"');"
								"hide"
							repeat
								array="&nbsp"
								times=8
							tags.a
								name=names.showAll
								href=join
									"javascript:showAll('"
									names.item
									"');hideAll('"
									names.showAll
									"');showAll('"
									names.hideAll
									"');hideAll('"
									names.show
									"');showAll('"
									names.hide
									"')"
								style="display:none"
								"show all"
							tags.a
								name=names.hideAll
								href=join
									"javascript:hideAll('"
									names.item
									"');hideAll('"
									names.hideAll
									"');showAll('"
									names.showAll
									"');hideAll('"
									names.hide
									"');showAll('"
									names.show
									"')"
								"hide all"
							tags.br *
							tags.div
								id=ids.item
								name=typeName
								argument.content
								tags.br *
		current=merge
			parent
			items
		file.write
			fileName=indexPath
			text=tags.html 
				tags.head 
					script *
					tags.title
						"Meta"
				tags.body
					"Meta is a simple programming language."
					chapter
						title="Installation"
						content=join
							"Please download from "
							tags.a
								href="http://developer.berlios.de/project/showfiles.php?group_id=2780"
								"here"
					chapter
						title="Language definition"
						content=join
							subchapter
								title="Select"
								content="The select expression lets you select."
							subchapter
								title="Statement"
								content="Statements asssign a value to a key."
							subchapter
								title="Call"
								content="Functions can called quite simply."
							subchapter
								title="Program"
								content="Programs create maps by executing statements."
							subchapter
								title="Function"
								content="Functions are a special type of statement, but they also create an expression."
							subchapter
								title="Literal"
								content="Literals create predefined maps."
					chapter
						title=".NET integration"
						content=join
							"Meta is implemented in C# and can directly access .NET objects and methods."
							subchapter
								title="Methods"
							subchapter
								title="Types"
							subchapter
								title="Fields"
							subchapter
								title="Properties"
							subchapter
								title="Events"
							subchapter=
								title="Conversions to Meta"
							subchapter=
								title="Conversions to .NET"
		browser indexPath
documentation=
	Miscellaneous=
		text=*
		subchapters=
			Introduction=
				text="Meta is a simple programming language."
			Installation=*
			Setup=*
	["The Meta programming language"]=
		text=*
		subchapters=
			Select=*
			Call=
				text=*
			Program=*
			Statement=*
			Function=*
			Literal=*
	[".NET integration"]=*
createWebsite=
	|
		current=map.merge
			map
			logic
			math
		html=html *
		show=
			|join foreach
				map=arg.value
				with=
					|if
						condition=isString arg.value
						then=
							|html.a
								name=arg.arg.arg.name
								html.p
									arg.arg.value
						else=
							|show
								value=arg.arg.value
								name=join
									arg.arg.arg.name
									arg.arg.key
		getTree=
			addNode=
				counter=*
				|
					parent.counter=increment counter
			|
				argument=arg
				mapKeys=keys arg.map
				current=join
					join apply
						array=range length mapKeys
						with=
							|
								key=mapKeys.[arg]
								value=argument.map.[key]
								addNode *
								result=join
									"d.add("
									integerToString addNode.counter
									","
									integerToString argument.parentNode
									",'"
									join
										mapKeys.[arg]
										if
											condition=contains
												map=value
												key="title"
											then=
												|value.title
									"','"
									"text.html#"
									argument.name
									"','"
									key
									"','text"
									"');"
									if
										condition=not isString value
										then=
											|getTree
												map=value
												parentNode=addNode.counter
												name=local.map.join
													argument.name
													key
								current=result
		content=
			|foreach
				map=arg
				with=
					|
						link="content.html"
						name="hello world"
						nodes=if
							condition=not isString arg.value
							then=
								|content arg.arg.value
		'"debug.print html.a
			href="source.html"
			"hello world"
		debug.print content meta"'
		structure=
			|keys merge arg
		nodes=
			|join apply
				array=arg
				with=
					|join
						"d.add"
						js.argumentList
							arg.id
							arg.parentNode
							arg.name
							arg.link
							""
							arg.target
						nodes arg
		tree=
			|join apply
				array=arg
				with=
					|join
						=
							=
								name="hello"
								link=arg.link
						tree arg.nodes
		x=content meta
		debug.print tree x
		websiteDirectory="C:\Projects\Meta\Website"
		directory.write
			directory=websiteDirectory
			files=
				["navigation.html"]=join
					html.head
						html.title
							"Meta"
						html.link
							rel="StyleSheet"
							href="dtree.css"
							type="text/css"
						html.script
							type="text/javascript"
							src="dtree.js"
					html.body
						html.div
							class="dtree"
							html.script
								type="text/javascript"
								'"
									<!--

									d = new dTree('d');
									d.add(0,-1,'Meta');
								"'
								getTree
									map=meta
									parentNode=*
									name="meta"
								"document.write(d);
									//-->"
				["index.html"]=html.frameset
					cols="20%,80%"
					html.frame
						name="navigation"
						src="navigation.html"
					html.frame
						name="content"
						src="content.html"
				["content.html"]=show
					value=meta
					name="meta"
		'"browser path.combine
			websiteDirectory
			"index.html""'
js=
	argumentList=
		|map.join
			"("
			map.pop map.join map.apply
				array=arg
				with=
					|map.join
						map.if
							condition=map.isInteger arg
							then=
								|integerToString arg.arg
							else=
								|map.join
									"'"
									arg.arg
									"'"
						","
			")"
directory=
	write=
		|
			argument=arg
			current=map.apply
				array=map.keys arg.files
				with=
					|
						file.write
							fileName=path.combine
								argument.directory
								arg
							text=argument.files.[arg]
debug=
	print=
		|console.writeLine Meta.Meta.FileSystem.Serialize.Value
			arg
|createWebsite *