sdltest=
	|
		current=SdlDotNet
		ball=Sprite
			"C:\Projects\Meta\Library\Paddle2.png"
		game
			|
				screen=Video.Screen.get *
				ball.Render
					screen
				screen.Update *
				mscorlib.Console.WriteLine
					"hello world"
|sdltest *
license='"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
game=
	|
		current=SdlDotNet
		Video.SetVideoModeWindow
			400
			300
		quit=*
		mainFunction=arg
		Events.Quit.add
			=
				|
					parent.parent.parent.quit=1
		library.map.while
			condition=
				|library.logic.not quit
			with=
				|
					Events.Poll *
					mainFunction *
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	map=
		while=
			|
				stop=arg.condition *
				next=
					[*]=
						|*
					=
						|
							arg.with *
							while arg
				next.[stop] arg
		while=
			|Meta.Library.While
				arg
		apply=
			|applyImplementation
				array=arg.array
				with=arg.with
				index=1
				result=*
			applyImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								with=arg.with
								index=math.add
									arg.index
									1
								object=Meta.ObjectMap
									arg.result
								argument=arg.with arg.array.[arg.index]
								object.Append
									argument
								result=object.Current.get *
					current=next.[stop] arg
		join=
			|Meta.Library.Join
				arg
		contains=
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			|
				object=Meta.ObjectMap
					arg
				current=Meta.StrategyMap
					object.Keys.get *
		merge=
			|sum
				array=arg
				with=
					|
						overwrite=arg.present
						current=sum
							array=keys arg.present
							with=
								|
									result=arg.previous
									result.[arg.present]=overwrite.[arg.present]
									current=result
							start=arg.previous
				start=*
		equal=
			|
				result=sum
					array=arg
					with=
						|
							first=Meta.ObjectMap
								arg.previous.previous
							current=
								equality=logic.and
									first.Equals
										arg.present
									arg.previous.equality
								previous=arg.present
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			|
				map=Meta.ObjectMap
					arg
				current=map.ArrayCount.get *
		sum=
			|sumImplementation
				index=1
				array=arg.array
				with=arg.with
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.with
									previous=arg.result
									present=arg.array.[arg.index]
								array=arg.array
								with=arg.with
					current=next.[stop] arg
	logic=
		not=
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=1
			table=
				[
					previous=1
					present=*
				]=*
				[
					previous=*
					present=1
				]=*
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
		or=
			|map.sum
				array=arg
				with=
					|table.[arg]
				start=*
			table=
				[
					previous=1
					present=*
				]=1
				[
					previous=*
					present=1
				]=1
				[
					previous=*
					present=*
				]=*
				[
					previous=1
					present=1
				]=1
	math=
		increment=
			|
				result=Meta.Integer.op_Addition
					Meta.Integer
						arg
					Meta.Integer
						1
				current=Meta.StrategyMap
					result
		increment=
			|
				result=arg
				result.[*]=arg
				current=result
		add=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
		multiply=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=1
		greater=
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			|Meta.StrategyMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.previous
							Meta.Integer
								arg.present
					start=*
	string=
		lower=
			|library.map.apply
				array=arg
				with=
					|mscorlib.Char.ToLower
						arg
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
html=
	|
		table=
			|tags.table
				text=library.map.join library.map.apply
					array=arg
					with=
						|tags.tr
							text=library.map.join library.map.apply
								array=arg
								with=
									|tags.td
										text=arg
		tags=library.map.merge library.map.apply
			with=
				|
					[arg]=
						name=arg
						|library.map.join
							"<"
							name
							argument=library.map.merge
								=
									text=*
									attribute=*
								arg
							library.map.join library.map.apply
								array=library.map.keys argument.attribute
								with=
									|library.map.join
										" "
										arg
										"="
										'"""'
										argument.attribute.[arg]
										'"""'
							">"
							library.map.join
								argument.text
								argument
							"</"
							name
							">"
			array=
				"html"
				"head"
				"title"
				"body"
				"h1"
				"h2"
				"h3"
				"h4"
				"h5"
				"h6"
				"p"
				"br"
				"pre"
				"b"
				"i"
				"table"
				"tr"
				"td"
				"form"
				"input"
				"a"
				"img"
				"font"
				"script"
				"div"
displayHtml=
	|
		fileName="C:\test.html"
		file.write
			file=fileName
			text=arg
		browser fileName
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
browser=
	|process
		fileName="firefox"
		arguments=arg
path=
	|library.map.sum
		array=arg
		with=
			|mscorlib.Path.Combine
				arg.previous
				arg.present
		start=*
console=
	write=
		|mscorlib.Console.Write
			arg
	readLine=
		|mscorlib.Console.ReadLine *
website=
	|
		current=library.map.merge
			library.map
			html *
		berliosLogo=
			|table
				=
					tags.a
						attribute=
							href="http://developer.berlios.de"
						text=tags.img
							attribute=
								src="http://developer.berlios.de/bslogo.php?group_id=2780"
								width="124"
								height="32"
								border="0"
								alt="BerliOS Logo"
		websiteDirectory="C:\Projects\Meta\Website"
		indexPath=path
			websiteDirectory
			"index.html"
		script=
			|tags.script
				attribute=
					language="Javascript 1.2"
					type="text/javascript"
				text="
					function show(id)
					{
						el = document.getElementById(id);
						el.style.display = '';
					}
					function hide(id)
					{
						el = document.getElementById(id);
						el.style.display = 'none';
					}
					function showAll(name)
					{
						elements=document.getElementsByName(name);
						elements[0].display='';
					}
					function hideAll(name)
					{
						elements=document.getElementsByName(name);
						elements[0].display='none';
					}
				"
		chapter=
			|join
				arg.title
				tags.a
					attribute=
						id="showThis"
						href="javascript:show('test');hide('showThis');show('hideThis')"
						style="display:none"
					text="show this chapter"
				tags.a
					attribute=
						id="hideThis"
						href="javascript:hide('test');hide('hideThis');show('showThis')"
					text="hide this chapter"
				tags.a
					attribute=
						name="showAll"
						href="javascript:showAll('chapter')"
						style="display:none"
					text="show all chapters"
				tags.a
					attribute=
						name="hideAll"
						href="javascript:hideAll('chapter')"
					text="hide all chapters"
				tags.br *
				tags.div
					attribute=
						id="test"
						name="chapter"
					text=join
						arg.text
						tags.br *
		file.write
			fileName=indexPath
			text=tags.html join
				tags.head join
					script *
					tags.title "Meta"
				tags.body join
					chapter
						title="hello world"
						text="jhaölksdflkasöasdjf"
					chapter
						title="come on everybody"
						text="asdfkasödkhfklsjdf"
		browser indexPath