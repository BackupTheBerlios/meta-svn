sdltest=
	|
		current=SdlDotNet
		ball=Sprite
			"C:\Projects\Meta\Library\Paddle2.png"
		game
			|
				screen=Video.Screen.get *
				ball.Render
					screen
				screen.Update *
				mscorlib.Console.WriteLine
					"hello world"
license='"
	Copyright (c) 2005 Christian Staudenmeyer
	
	Permission is hereby granted, free of charge, to any person obtaining
	a copy of this software and associated documentation files (the
	"Software"), to deal in the Software without restriction, including
	without limitation the rights to use, copy, modify, merge, publish,
	distribute, sublicense, and/or sell copies of the Software, and to
	permit persons to whom the Software is furnished to do so, subject to
	the following conditions:
	
	The above copyright notice and this permission notice shall be
	included in all copies or substantial portions of the Software.
	
	THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
	EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
	NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
	BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
	ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
	CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
	SOFTWARE."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			mscorlib.Directory.CreateDirectory
				mscorlib.Path.GetDirectoryName
					arg.fileName
			writer=mscorlib.StreamWriter
				arg.fileName
			writer.Write
				arg.text
			writer.Close *
game=
	|
		current=SdlDotNet
		Video.SetVideoModeWindow
			400
			300
		quit=*
		mainFunction=arg
		Events.Quit.add
			=
				|
					parent.parent.parent.quit=1
		local.map.while
			condition=
				|local.logic.not quit
			with=
				|
					Events.Poll *
					mainFunction *
basicTest=
	|
		current=local.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		scopeTest="default"
		scopeFunction=
			inScope="right"
			|
				parent.parent.scopeTest=inScope
		inScope="wrong"
		scopeFunction *
		scopeFromFunctionData="right"
		scopeFunctionFunction=
			scopeFromFunctionData="wrong"
			|
				|scopeFromFunctionData
		scopeFromFunction=scopeFunctionFunction *
		scopeFromFunctionTest=scopeFromFunction *
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=local.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.GetValue
			1
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=local.logic.not local.map.equal
					arg
					10
				whileBranches=
					=
						|loop local.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
console=
	writeLine=
		|mscorlib.Console.WriteLine
			arg
	write=
		|mscorlib.Console.Write
			arg
	readLine=
		|mscorlib.Console.ReadLine *
integerToString=
	documentation="Converts an integer to a string."
	|
		int=Meta.Integer
			arg
		current=int.ToString *
map=
	isInteger=
		|
			object=Meta.ObjectMap
				arg
			current=object.IsInteger.get *
	isString=
		|
			object=Meta.ObjectMap
				arg
			current=object.IsString.get *
	if=
		|
			argument=merge
				=
					else=
						|*
					then=
						|*
				arg
			cases=
				[1]=argument.then
				[*]=argument.else
			current=cases.[argument.condition] *
	repeat=
		documentation="Repeats an array a given number of times."
		|
			argument=arg.array
			current=join apply
				array=range arg.times
				with=
					|argument
	range=
		documentation="Returns an array containing all numbers from 1 to the argument."
		|
			array=*
			counter=1
			limit=math.add
				arg
				1
			count=
				|
					parent.parent.array.[counter]=counter
					parent.parent.counter=math.add
						counter
						1
			while
				condition=
					|math.smaller
						counter
						limit
				with=
					|
						current=count arg
			current=array
	remove=
		documentation="Removes a key from a map."
		|Meta.Library.Remove
			arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|
			stop=arg.condition *
			next=
				[*]=
					|*
				=
					|
						arg.with *
						while arg
			next.[stop] arg
	while=
		documentation="Calls a function as long as the condition function returns 1."
		|Meta.Library.While
			arg
	apply=
		documentation="Calls a function with every value in an array as an argument and returns the results as an array."
		|applyImplementation
			array=arg.array
			with=arg.with
			index=1
			result=*
		applyImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|applyImplementation
							array=arg.array
							with=arg.with
							index=math.add
								arg.index
								1
							object=Meta.ObjectMap
								arg.result
							argument=arg.with arg.array.[arg.index]
							object.Append
								argument
							result=object.Current.get *
				current=next.[stop] arg
	join=
		documentation="Concatenates arrays."
		|Meta.Library.Join
			arg
	contains=
		documentation="Determines whether a map contains a key."
		|
			object=Meta.ObjectMap
				arg.map
			current=object.ContainsKey
				arg.key
	keys=
		documentation="Returns the keys of a map in an array."
		|
			object=Meta.ObjectMap
				arg
			current=Meta.StrategyMap
				object.Keys.get *
	merge=
		documentation="Combines several maps into one."
		|sum
			array=arg
			with=
				|
					overwrite=arg.present
					current=sum
						array=keys arg.present
						with=
							|
								result=arg.previous
								result.[arg.present]=overwrite.[arg.present]
								current=result
						start=arg.previous
			start=*
	equal=
		documentation="Determines whether maps are identical."
		|
			result=sum
				array=arg
				with=
					|
						first=Meta.ObjectMap
							arg.previous.previous
						current=
							equality=logic.and
								first.Equals
									arg.present
								arg.previous.equality
							previous=arg.present
				start=
					equality=1
					previous=arg.[1]
			current=result.equality
	length=
		documentation="Returns the length of an array."
		|
			map=Meta.ObjectMap
				arg
			current=map.ArrayCount.get *
	sum=
		|sumImplementation
			index=1
			array=arg.array
			with=arg.with
			result=arg.start
		sumImplementation=
			|
				stop=math.greater
					arg.index
					length arg.array
				next=
					=
						|arg.result
					[*]=
						|sumImplementation
							index=math.increment arg.index
							result=arg.with
								previous=arg.result
								present=arg.array.[arg.index]
							array=arg.array
							with=arg.with
				current=next.[stop] arg
logic=
	not=
		documentation="Negates a boolean."
		|table.[arg]
		table=
			[*]=1
			[1]=*
	and=
		documentation="Returns whether all booleans are true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=1
		table=
			[
				previous=1
				present=*
			]=*
			[
				previous=*
				present=1
			]=*
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
	or=
		documentation="Returns whether at least one boolean is true."
		|map.sum
			array=arg
			with=
				|table.[arg]
			start=*
		table=
			[
				previous=1
				present=*
			]=1
			[
				previous=*
				present=1
			]=1
			[
				previous=*
				present=*
			]=*
			[
				previous=1
				present=1
			]=1
math=
	increment=
		documentation="Increments an integer."
		|
			result=Meta.Integer.op_Addition
				Meta.Integer
					arg
				Meta.Integer
					1
			current=Meta.StrategyMap
				result
	add=
		documentation="Adds integers."
		|Meta.StrategyMap
			map.sum
				array=arg
				with=
					|Meta.Integer.op_Addition
						Meta.Integer
							arg.previous
						Meta.Integer
							arg.present
				start=*
	multiply=
		documentation="Multiplies integers."
		|Meta.StrategyMap
			map.sum
				array=arg
				with=
					|Meta.Integer.op_Multiply
						Meta.Integer
							arg.previous
						Meta.Integer
							arg.present
				start=1
	greater=
		documentation="Determines whether the first integer is greater than the second integer."
		|Meta.Integer.op_GreaterThan
			Meta.Integer
				arg.[1]
			Meta.Integer
				arg.[2]
	smaller=
		documentation="Determines whether the first integer is smaller than the second integer."
		|Meta.Integer.op_LessThan
			Meta.Integer
				arg.[1]
			Meta.Integer
				arg.[2]
bitwise=
	or=
		documentation="Performs a bitwise or operation on integers."
		|Meta.StrategyMap
			map.sum
				array=arg
				with=
					|Meta.Integer.op_BitwiseOr
						Meta.Integer
							arg.previous
						Meta.Integer
							arg.present
				start=*
string=
	lower=
		documentation="Converts a string to lowercase."
		|local.map.apply
			array=arg
			with=
				|mscorlib.Char.ToLower
					arg
libraryTest=
	|
		current=local.map.merge
			parent
			local.map
			local.logic
			local.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=local.bitwise.or
					8
					20
			mapTest=
				if=if
					condition=1
					then=
						|"if test successful"
				remove=remove
					map=
						x="hello"
						y="world"
					key="x"
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|add
							arg
							1
					current=apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|smaller
								counter
								10
						with=
							|SetCounter increment counter
					current=counter
			bitwiseTest=local.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
html=
	|
		table=
			|tags.table
				inner=local.map.join local.map.apply
					array=arg
					with=
						|tags.tr
							inner=local.map.join local.map.apply
								array=arg
								with=
									|tags.td
										inner=arg
		tags=local.map.merge local.map.apply
			with=
				|
					[arg]=
						name=arg
						|local.map.join
							"<"
							name
							argument=local.map.merge
								=
									inner=*
								arg
							local.map.join local.map.apply
								array=local.map.keys local.map.remove
									map=argument
									key="inner"
								with=
									|local.map.join
										" "
										arg
										"="
										'"""'
										argument.[arg]
										'"""'
							">"
							argument.inner
							"</"
							name
							">"
			array=
				"html"
				"head"
				"title"
				"body"
				"h1"
				"h2"
				"h3"
				"h4"
				"h5"
				"h6"
				"p"
				"br"
				"pre"
				"b"
				"i"
				"table"
				"tr"
				"td"
				"form"
				"input"
				"a"
				"img"
				"font"
				"script"
				"div"
				"center"
				"frame"
				"frameset"
displayHtml=
	|
		fileName="C:\test.html"
		file.write
			fileName=fileName
			text=arg
		browser fileName
process=
	|
		process=System.Process *
		startInfo=process.StartInfo.get *
		startInfo.FileName.set
			arg.fileName
		startInfo.Arguments.set
			arg.arguments
		process.Start *
browser=
	|process
		fileName="firefox"
		arguments=arg
path=
	|local.map.sum
		array=arg
		with=
			|mscorlib.Path.Combine
				arg.previous
				arg.present
		start=*
meta=
	introduction="Meta is a small programming language that is designed to be kept in the
		programmer's head all at once."
	chapters=
		Tutorial=
			introduction="This small tutorial is supposed to guide you through most of Meta's
				functionality with a few examples."
			chapters=*
		[".NET"]=
			introduction="This part explains how the integration of Meta with .NET works."
			chapters=
				Objects=*
				Classes=*
				Enumerations=*
				Delegates=*
				Events=*
				Properties=*
				Indexers=*
				Methods=*
		Language=
			introduction="This part defines the Meta programming language itself."
			chapters=
				Maps=
					explanation="Maps are the foundation of Meta. They are the only data type
						that exists in Meta. Most programming languages use several or even many
						different data types. Often, data types only exist in the form of
						libraries and the only way to build abstractions of data is using
						a builtin concept of 'classes' or something like this. The reason there
						are usually several data types is efficiency. Maps are more general than
						arrays, for example. Most programming languages, however make both 
						avaiblable, however, even though the interface of a map is more general
						than that of an array. It is thus possible in these languages to
						tell the interpreter or compiler which implementation strategy you
						want to use. If you are willing to take some restrictions, the
						performance will be better. The program structure will not be any
						simpler, though. 
						Likewise, many programming languages use things like 'objects',
						local variable scope, global variable scope, function parameters and
						so on as a way to support a restricted form of the map interface.
						By creating a different concept for every case where something map-like
						is called for, these concepts can be implemented efficiently very easily.
						Meta cannot be implemented efficiently very easily, however it can
						be implemented as efficiently as those other programming languages,
						although it is a bit more effort. On the other hand, implementing it
						somewhat inefficient is much easier than implementing any of those other
						programming languages at all.
						
						Meta makes programming much easier by using one and the same interface
						for all these cases. This also allows much more flexibility, because
						most programming language designers did not think of all the things
						programmers would want to do with their language. Since they did not 
						think of it, they could not optimize it, so it is not included in the
						language. In Meta, it might not be optimized, but it is possible.
						Being so general, Meta is also much more concise and easier to read
						and unserstand. Meta cleanly separates the design, or interface, from
						the implementation."
				emptyMap=
					title="Creating empty maps"
					tutorial="There is not really much you can with just an empty map.
						Every empty map is exactly the same as all the others"
					explanation="Evaluates to a map containing zero key-value pairs."
					grammar='"
						'*'
					"'
					code="
						literal=*
						"
				select=
					title="Selecting values"
					explanation="Evaluates to the value of the last lookup. The first lookup
						searches its key in the current scope if necessary. Subsequent lookups
						look up their keys in the previous result without searching.
					"
					grammar="
						lookup ('.' lookup)*
					"
					code="
						select=
							[1]=<expression>
							[2]=<expression>
							[3]=<expression>
							...
						"
				integer=
					title="Creating integers"
					explanation="Evaluates to a map representing the given integer. The map
						is as deep as the number it represents."
					grammar='"
						('1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9') ('0'|'1'|'2'|'3'|'4'|'5'|'6'|'7'|'8'|'9')*
					"'
					code="
						literal=2342
						"
				string=
					title="Creating strings"
					explanation="Evaluates to an array containing the provided unicode characters
						in the form of integers."
					grammar=''"
						'''* '"' <any unicode character>+ '"' '''* {same number of ''' as at start of string}
					code="
						literal="string"
						"
				"''
				program=
					title="Creating maps"
					grammar="
						indentation statement (sameIndentation statement)* dedentation
					"
					explanation="Evaluates to the map that results from executing all statements
						in a map that is initially empty."
					subGrammar=
						NewLine="
							('\n'|'\n\r')
						"
						Whitespace="
							(' '|'\t')*
						"
						SameIndentation="
							whitespace newLine <as many tabs as in previous line>
						"
						Indentation="
							(<start of file> | (newLine <one tab more than in previous line>))
						"
						Dedentation="
							(<end of file> | <next line has one tab less at start of line than this line>)
						"
					code="
						program=
							[1]=<statement>
							[2]=<statement>
							[3]=<statement>
							...
						"
				statement=
					title="Assigning values to keys"
					explanaton="Assigns the result from an expression to a key."
					grammar="
						( ( (lookup ('.' lookup)*)? '=')? expression) | function
					"
					code="
						key=
							[1]=<expression>
							[2]=<expression>
							[1]=<expression>
						value=<expression>
						"
				lookup=
					title="Looking up values"
					explanation="Is a syntactical element used both in statements and in
						select expressions."
					grammar=''"
						(any unicode character except: '*','=','|','.','"',''','[',']') + 
						| ("[" (select|string|integer|emptyMap) "]")
				"''
				function=
					title="Creating functions"
					explanation="Assigns the code-equivalent of 'expression' to the key 'function'
						in the current map."
					grammar="
						'|' expression
					"
					code='"
						key=
							[1]="function"
						value=<expression>
						"'
				call=
					title="Calling functions"
					explanation="Evaluates to the return value from calling the 'select' with an expression
						as the argument."
					grammar="
						select ' '? expression
					"
					code="
						callable=<select>
						argument=<expression>
						"
				expression=
					title="Creating values"
					explanation="Anything that returns a value is an expression."
					grammar="
						emptyMap|integer|string|program|select|call
					"
website=
	|
		current=local.map.merge
			local.map
			html *
		berliosLogo=
			|table
				=
					tags.a
						href="http://developer.berlios.de"
						inner=tags.img
							src="http://developer.berlios.de/bslogo.php?group_id=2780"
							width="124"
							height="32"
							border="0"
							alt="BerliOS Logo"
		websiteDirectory="C:\Projects\Meta\Website"
		indexPath=path
			websiteDirectory
			"index.html"
		script=
			|tags.script
				language="Javascript 1.2"
				type="text/javascript"
				inner="
					function show(id)
					{
						el = document.getElementById(id);
						el.style.display = '';
					}
					function hide(id)
					{
						el = document.getElementById(id);
						el.style.display = 'none';
					}
					function showAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='';
						}
					}
					function hideAll(name)
					{
						elements=document.getElementsByName(name);
						for(var i=0;i<elements.length;i++)
						{
							elements[i].style.display='none';
						}
					}
				"
		getId=
			id=*
			|
				parent.id=local.math.increment id
				current=local.integerToString id
		items=merge apply
			array=
				"chapter"
				"example"
				"subchapter"
				"subsubchapter"
			with=
				|
					[arg]=
						typeName=arg
						|join
							argument=merge
								=
									title=typeName
									content=*
								arg
							tags.div
								inner=tags.b
									inner=tags.font
										size="+1"
										inner=argument.title
							ids=
								item=getId *
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							names=
								item=typeName
								hideAll=join
									"hideAll"
									item
								showAll=join
									"showAll"
									item
								hide=join
									"hide"
									item
								show=join
									"show"
									item
							tags.a
								id=ids.show
								style=""
								name=names.show
								style="display:none"
								href=join
									"javascript:show('"
									ids.item
									"');hide('"
									ids.show
									"');show('"
									ids.hide
									"');"									
								inner=join
									"show"
							tags.a
								id=ids.hide
								name=names.hide
								href=join
									"javascript:hide('"
									ids.item
									"');hide('"
									ids.hide
									"');show('"
									ids.show
									"');"
								inner="hide"
							repeat
								array="&nbsp"
								times=8
							tags.a
								name=names.showAll
								href=join
									"javascript:showAll('"
									names.item
									"');hideAll('"
									names.showAll
									"');showAll('"
									names.hideAll
									"');hideAll('"
									names.show
									"');showAll('"
									names.hide
									"')"
								style="display:none"
								inner=join
									"show all"
							tags.a
								name=names.hideAll
								href=join
									"javascript:hideAll('"
									names.item
									"');hideAll('"
									names.hideAll
									"');showAll('"
									names.showAll
									"');hideAll('"
									names.hide
									"');showAll('"
									names.show
									"')"
								inner=join
									"hide all"
							tags.br *
							tags.div
								id=ids.item
								name=typeName
								inner=join
									argument.content
									tags.br *
		current=merge
			parent
			items
		file.write
			fileName=indexPath
			text=tags.html 
				inner=join
					tags.head 
						inner=join
							script *
							tags.title
								inner="Meta"
					tags.body
						inner=join
							"Meta is a simple programming language."
							chapter
								title="Installation"
								content=join
									"Please download from "
									tags.a
										href="http://developer.berlios.de/project/showfiles.php?group_id=2780"
										inner="here"
							chapter
								title="Language definition"
								content=join
									subchapter
										title="Select"
										content="The select expression lets you select."
									subchapter
										title="Statement"
										content="Statements asssign a value to a key."
									subchapter
										title="Call"
										content="Functions can called quite simply."
									subchapter
										title="Program"
										content="Programs create maps by executing statements."
									subchapter
										title="Function"
										content="Functions are a special type of statement, but they also create an expression."
									subchapter
										title="Literal"
										content="Literals create predefined maps."
							chapter
								title=".NET integration"
								content=join
									"Meta is implemented in C# and can directly access .NET objects and methods."
									subchapter
										title="Methods"
									subchapter
										title="Types"
									subchapter
										title="Fields"
									subchapter
										title="Properties"
									subchapter
										title="Events"
									subchapter=
										title="Conversions to Meta"
									subchapter=
										title="Conversions to .NET"
		browser indexPath
documentation=
	Miscellaneous=
		text=*
		subchapters=
			Introduction=
				text="Meta is a simple programming language."
			Installation=*
			Setup=*
	["The Meta programming language"]=
		text=*
		subchapters=
			Select=*
			Call=
				text=*
			Program=*
			Statement=*
			Function=*
			Literal=*
	[".NET integration"]=*
|
	current=map.merge
		map
		logic
		math
	html=html *
	html=html.tags
	show=
		|
			showArg=arg
			map=arg.value
			current=join apply
				array=keys map
				with=
					|
						key=arg
						value=map.[key]
						current=if
							condition=isString value
							then=
								|html.a
									name=join
										showArg.name
										key
									inner=html.p
										inner=value
							else=
								|show
									value=value
									name=join
										showArg.name
										key
	getTree=
		addNode=
			counter=*
			|
				parent.counter=increment counter
		|
			argument=arg
			mapKeys=keys arg.map
			current=join apply
				array=range length mapKeys
				with=
					|
						key=mapKeys.[arg]
						value=argument.map.[key]
						addNode *
						result=join
							"d.add("
							integerToString addNode.counter
							","
							integerToString argument.parentNode
							",'"
							join
								mapKeys.[arg]
							"','"
							"text.html#"
							join
								argument.name
								key
							"','"
							key
							"','text"
							"');"
							if
								condition=not isString value
								then=
									|getTree
										map=value
										parentNode=addNode.counter
										name=local.map.join
											argument.name
											key
						current=result
	file.write
		fileName="C:\contents.html"
		text=join
			'"
				<head>
					<title>Destroydrop &raquo; Javascripts &raquo; Tree</title>

					<link rel="StyleSheet" href="dtree.css" type="text/css" />
					<script type="text/javascript" src="dtree.js"></script>

				</head>
				<body>
				<div class="dtree">
				<script type="text/javascript">
				
				
				<!--

				d = new dTree('d');
				d.add(0,-1,'Meta');
				"'
			getTree
				map=meta
				parentNode=*
				name="meta"
			'"
				document.write(d);

				//-->
				</script>
				
				</div>
				</body>
				"'
	file.write
		fileName="C:\index.html"
		text=html.frameset
			cols="20%,80%"
			inner=join
				html.frameset
					rows="60%,40%"
					inner=join
						html.frame
							name="contents"
							src="contents.html"
						html.frame
							name="structure"
							src="structure.html"
				html.frame
					name="text"
					src="text.html"
	file.write
		fileName="C:\text.html"
		text=show
			value=meta
			name="meta"			
	'"file.write
		fileName="C:\structure.html"
		text=getStructure meta.chapters
	browser "C:\index.html""'
	subKeys=
		|
			argument=arg
			current=join apply
				array=keys arg
				with=
					|keys scope.arg.[arg]
	console.write join subKeys meta.chapters
	unique=
		|keys merge apply
			array=arg
			with=
				|
					arg
	similar=
		|
			result=*
			maps=arg.maps
			apply
				array=unique subKeys maps
				with=
					|*