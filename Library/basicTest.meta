#	Meta is a programming language.
#	Copyright (C) 2004 Christian Staudenmeyer "christianstaudenmeyer@web.de"
#
#	This program is free software; you can redistribute it and/or
#	modify it under the terms of the GNU General Public License version 2
#	as published by the Free Software Foundation.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
|
	current=map.Merging
		parent
		=
			"AssignedToCurrent"
	unicodeText="äaba"
	current=map.Merging
		parent
		boolean
		map
		number
		array
#	internetTest=web.localhost.test
	parent.parent.testSubDir.x=*
	persistantDeleteTest=testSubDir.x
	parent.parent.testSubDir.x=
		a="b"
		x=
			x="hello"
			y="world"
	integerHashTest=
		[2]="correct hash content"
		hashTestData=
			[*]=
				[*]=*
		hashTest=[hashTestData]
	negativeInteger=100
	negativeInteger.x="hello"
	integerIncrementTest=5
	integerIncrementTest.[*]=integerIncrementTest
	integerDecrementTest=5
	integerDecrementTest=integerDecrementTest.[*]
	persistenceTest=testSubDir
	literalEscapeTest=
		[1]=\"asdf"\
		[2]=\\"asdf"\\
		[3]=\\"as"\df"\\
		[4]=\\\"as"\\df"\\\
		[5]=\\\\\\\\\\\\\\\\\"as"\\\\\\\\\\\\\\\\df"\\\\\\\\\\\\\\\\\
	"ImpliedAutokey"
	="Autokey"
	gacTest=System.Collections
#
#		some comment
	lazyGACTest=Microsoft.CSharp
#	metaLibTest=metaLib
	commandLineArguments=parameter
#	libraryAssemblyTest=testClasses
#		asdfasdf	fff
#	thisIsInAComment|
#		still comment
#	some more comment
	aMap=
		["a"]="a"
	[aMap]="Object"
	["normal symbol"]="NormalSymbol"
	lookupSymbol="LookupSymbol"
	["long key symbol"]="LookupExtendedSymbol"
	lookedUpMap=[aMap]
	lookedUpNormalSymbol=["normal symbol"]
	lookedUpSymbol=lookupSymbol
	lookedUpLongSymbol=["long key symbol"]
	object=
		a="default"
		autoSearch="default"
		b=*
		SetA=
			|
				parent.parent.a="c"
				parent.parent.autoSearch="changed"
		SetB=
			|
				parent.parent.b.[1]=parameter.value
				current="changed"
		x=
			a="b"
			c="d"
		=
			|
				current.a="b"
	a="default"
	b=*
	aSet=object.SetA*
	bSet=object.SetB
		value=
			x=7
			z=1
	ReturnEverything=
		|
			current=parameter
	everythingReturned=ReturnEverything
		"a"
		"b"
		"c"
	variableAsArgument=ReturnEverything
		"x"
		"y"
		"z"
	ReturnFunction=
		|
			current=
				|
					current=
						1
						2
						3
	SetCurrent=
		|
			current=
				parameter=parameter
				x=parameter.symbol
			current=x
	thisSet=SetCurrent
		symbol="haha"
	FirstLevel=
		|
			SecondLevel parameter
	SecondLevel=
		|parameter
	argTest=FirstLevel
		a="z"
	concatenate=array.Concatenation
		"x"
		"yz"
	current=map.Merging
		parent
		testClasses
	TestClass.NestedClass.field=5
	nestedClassTest=TestClass.NestedClass.field
	testClass=TestClass*
	testClass.floatValue=
		numerator=1
		denominator=3
	testClass.doubleValue=
		numerator=1
		denominator=3
	testClass.decimalValue=
		numerator=1
		denominator=3
	TestClass.boolTest=1
	boolTest=TestClass.boolTest
	memberTest=MemberTest*
	MemberTest.classField="a"
	memberTest.instanceField="b"
	MemberTest.ClassProperty.Set
		memberTest.InstanceProperty.Get*
	classPropertyValue=MemberTest.ClassProperty.Get*
	memberTest.InstanceProperty.Set
		MemberTest.ClassProperty.Get*
	instancePropertyValue=memberTest.InstanceProperty.Get*
	interceptedSymbol="/hello/"
	positionalNoConversion=PositionalNoConversion
		"m"
		"n"
		"o"
	positionalNoConversionConcatenated=positionalNoConversion.Concatenate
		"r"
		"s"
		"t"
	namedNoConversion=NamedNoConversion
		=
			"m"
			y="n"
	namedNoConversionConcatenated=namedNoConversion.Concatenate
		=
			c="t"
			"r"
	indexerNoConversion=IndexerNoConversion*
	indexerNoConversion.Item.Set
		"abc"
		"hihi"
	indexerNoConversionIndexed=indexerNoConversion.Item.Get
		"abc"
	interceptedSymbolTwo=1
	k="hello"
	xyz="w"
	literalFunction=
		|5
	literalFunctionResult=literalFunction*
	someFunction=
		|
			current="simple function this"
	callFunction=
		|someFunction
	callFunctionResult=callFunction*
	delayedFunction=
		|
			|
				x="y"
	delayedFunctionResult=delayedFunction *
	value="xyz"
	selectionFunction=
		|value
	selectionFunctionResult=selectionFunction *
	bigInteger=89383838383832839123497123047217340712340720347072304702340720347
	upperLevel="unchanged"
	SetUpperLevel=
		|
			parent.parent.upperLevel=parameter
	ChangeUpperLevel=
		|
			SetUpperLevel "changed"
	ChangeUpperLevel*
	staticEventChanged=*
	ChangeStaticEvent=
		|
			parent.parent.staticEventChanged=parameter
	TestClass.staticEvent.Add
		=
			|
				ChangeStaticEvent 1
				current=parameter.[1]
	staticEvent=TestClass.staticEvent
	TestClass.TakeDelegate
		=
			|"resultFromDelegate"
	resultFromDelegate=TestClass.GetResultFromDelegate*
	staticEventResult=TestClass.staticEvent 
		testClass
	instanceEventChanged=*
	testClass.instanceEvent.Add
		=
			|
				parent.parent.parent.instanceEventChanged=1
				current=parameter.[1]
	instanceEvent=testClass.instanceEvent
	instanceEventResult=testClass.instanceEvent
		5
	one=1
	two=2
	firstIf="unchanged"
	secondIf="unchanged"
	firstIfCondition=Equality
		1
		one
	firstIfBranches=
		[1]=
			|"then"
		[*]=
			|"else"
	firstIf=firstIfBranches.[firstIfCondition]*
	bigNumber=50020202029029233344
	secondSwitch="unchanged"
	secondSwitchCases=
		[1]="one"
		[2]="two"
		[3]="three"
	secondSwitch=secondSwitchCases.[3]
	emptyMap=*
	emptyFunction=
		|
			x="hello"
	emptyFunctionResult=emptyFunction*
	font=System.Drawing.Font
		"Courier New"
		[2]=
			numerator=10
			denominator=1
	decimalTest=
		numerator=5023
		denominator=100
	fractionTest=
		numerator=4
		denominator=52
	stringTest="hello"
	stringTest.[6]=stringTest.[1]
	helloh="hi"
	stringStrategyHashTest=[stringTest]
	x=
		aLongText="
			hello world!
			hello!
			"
	arrayList=System.Collections.ArrayList*
	arrayList.Add 
		"hello"
	arrayListResult=arrayList.Item.Get
		*
	textBox=System.Windows.Forms.TextBox*
	textBox.Text.Set
		"
			Alle meine Entchen,
			schwimmen auf dem See,
			schwimmen auf dem See,
			Köpfchen in das Wasser,
			Schwaenzchen in die Hoeh."
	lines=textBox.Lines.Get*
	alleMeineText=lines.[1]
	lines.[5]="bwuhahaha"
	tabText="			hello"
	escapedText="\#\n\\\t"
	whileCounter=*
	loop=
		|
			whileDecision=not Equality
				parameter
				10
			whileBranches=
				[1]=
					|loop add
						parameter
						1
#					 
				[*]=
					|parameter
			current=whileBranches.[whileDecision] parameter
	whileCounter=loop 3
#
#		
#
	returnInMap=
		|
			result=parameter
	literalAsArgument=returnInMap 1
	returnFunction=
		|
			|"functionResult"
	returnArg=
		|parameter
	myArg=
		|
			hello="world"
	funcReturnTest=returnArg myArg*
	documentedFunction=
		doc="This function returns #hello ."
		|"hello"
	docFunctionResult=documentedFunction*
#	end comment
