//	Meta is a programming language.
//	Copyright (C) 2004 Christian Staudenmeyer <christianstaudenmeyer@web.de>
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License version 2
//	as published by the Free Software Foundation.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
this:map.Merging
	parent
	:
		"AssignedToCurrent"
unicodeText:"äaba"
this:map.Merging
	parent
	logic
	map
	math
	array
parent.parent.testSubDir.x:*
persistantDeleteTest:testSubDir.x
parent.parent.testSubDir.x:
	a:"b"
	x:
		x:"hello"
		y:"world"
integerHashTest:
	2:"correct hash content"
	hashTestData:
		[*]:
			[*]:*
	hashTest:[hashTestData]
negativeInteger:"-100"
negativeInteger.x:"hello"
subtractionTest:math.Sum
	"-100"
	Opposite "1000"
integerIncrementTest:"5"
integerIncrementTest.0:integerIncrementTest
integerDecrementTest:"5"
integerDecrementTest:integerDecrementTest.0
persistenceTest:testSubDir
literalEscapeTest:
	1:"@asdf@"
	2:"@"asdf"@"
	3:"@"as"@df"@"
	4:"@"@as"@"df@"@"
	5:"@"@"@"@"@"@"@"@"as"@"@"@"@"@"@"@"@df"@"@"@"@"@"@"@"@"
applyMethod:=Sum
	arg
	"1"
applyTest:Application
	function:applyMethod
	array:
		"1"
		"2"
		"3"
ifTestCondition:Equality
	"1"
	"1"
ifTestCases:
	1:
		'"it is true"
	0:
		'"it is false"
ifTest:ifTestCases.[ifTestCondition]*
//ifTest:If
//	condition:Equal
//		"1"
//		"1"
//	then:
//		'"it is true"
//	else:
//		'"it is false"
"ImpliedAutokey"
:"Autokey"
gacTest:System.Collections

	//some comment
lazyGACTest:Microsoft.CSharp
//metaLibTest:metaLib
commandLineArguments:arg
//libraryAssemblyTest:testClasses
	//	asdfasdf	fff
//thisIsInAComment'
	//  still comment
// some more comment
aMap:
	["a"]:"a"
[aMap]:"Object"
["normal symbol"]:"NormalSymbol"
lookupSymbol:"LookupSymbol"
["long key symbol"]:"LookupExtendedSymbol"
lookedUpMap:[aMap]
lookedUpNormalSymbol:["normal symbol"]
lookedUpSymbol:lookupSymbol
lookedUpLongSymbol:["long key symbol"]
object:
	a:"default"
	autoSearch:"default"
	b:*
	SetA:=
		parent.parent.a:"c"
		parent.parent.autoSearch:"changed"
	SetB:
		'
			parent.parent.b.1:arg.value
			this:"changed"
	x:
		a:"b"
		c:"d"
	:
		'
			this.a:"b"
a:"default"
b:*
aSet:object.SetA*
bSet:object.SetB
	value:
		x:"7"
		z:"1"
ReturnEverything:
	'
		this:arg
everythingReturned:ReturnEverything
	"a"
	"b"
	"c"
variableAsArgument:ReturnEverything
	"x"
	"y"
	"z"
ReturnFunction:
	'
		this:
			'
				this:
					"1"
					"2"
					"3"
SetCurrent:
	'
		this:
			arg:arg
			x:arg.symbol
		this:x
thisSet:SetCurrent
	symbol:"haha"
FirstLevel:
	'
		SecondLevel arg
SecondLevel:
	'arg
argTest:FirstLevel
	a:"z"
concatenate:array.Concatenation
	"x"
	"yz"
this:map.Merging
	parent
	testClasses
TestClass.NestedClass.field:"5"
nestedClassTest:TestClass.NestedClass.field
testClass:TestClass*
testClass.floatValue:"1/3"
testClass.doubleValue:"1/3"
testClass.decimalValue:"1/3"
TestClass.boolTest:"1"
boolTest:TestClass.boolTest
memberTest:MemberTest*
MemberTest.classField:"a"
memberTest.instanceField:"b"
MemberTest.ClassProperty.set
	memberTest.InstanceProperty.get*
classPropertyValue:MemberTest.ClassProperty.get*
memberTest.InstanceProperty.set
	MemberTest.ClassProperty.get*
instancePropertyValue:memberTest.InstanceProperty.get*
interceptedSymbol:"/hello/"
positionalNoConversion:PositionalNoConversion
	"m"
	"n"
	"o"
positionalNoConversionConcatenated:positionalNoConversion.Concatenate
	"r"
	"s"
	"t"
namedNoConversion:NamedNoConversion
	:
		"m"
		y:"n"
namedNoConversionConcatenated:namedNoConversion.Concatenate
	:
		c:"t"
		"r"
indexerNoConversion:IndexerNoConversion*
indexerNoConversion.abc:"hihi"
indexerNoConversionIndexed:indexerNoConversion.abc
interceptedSymbol2:"1"
k:"hello"
xyz:"w"
literalFunction:
	'"5"
literalFunctionResult:literalFunction*
someFunction:
	'
		this:"simple function this"
callFunction:
	'someFunction
callFunctionResult:callFunction*
delayedFunction:
	'
		'
			x:"y"
delayedFunctionResult:delayedFunction *
value:"xyz"
selectionFunction:
	'value
selectionFunctionResult:selectionFunction *
bigInteger:"89383838383832839123497123047217340712340720347072304702340720347"
upperLevel:"unchanged"
SetUpperLevel:=
	parent.parent.upperLevel:arg
ChangeUpperLevel:
	'
		SetUpperLevel "changed"
ChangeUpperLevel*
staticEventChanged:"0"
ChangeStaticEvent:=
	parent.parent.staticEventChanged:arg
TestClass.staticEvent.add
	:
		'
			ChangeStaticEvent "1"
			this:arg.1
staticEvent:TestClass.staticEvent
TestClass.TakeDelegate
	:
		'"resultFromDelegate"
resultFromDelegate:TestClass.GetResultFromDelegate*
staticEventResult:TestClass.staticEvent 
	testClass
instanceEventChanged:"0"
testClass.instanceEvent.add
	:
		'
			parent.parent.parent.instanceEventChanged:"1"
			this:arg.1
instanceEvent:testClass.instanceEvent
instanceEventResult:testClass.instanceEvent
	"5"
one:"1"
two:"2"
firstIf:"unchanged"
secondIf:"unchanged"
firstIfCondition:Equality
	"1"
	one
firstIfBranches:
	1:
		'"then"
	0:
		'"else"
firstIf:firstIfBranches.[firstIfCondition]*
bigNumber:"50020202029029233344"
secondSwitch:"unchanged"
secondSwitchCases:
	1:"one"
	2:"two"
	3:"three"
secondSwitch:secondSwitchCases.3
emptyMap:*
emptyFunction:
	'
		x:"hello"
emptyFunctionResult:emptyFunction*
font:System.Drawing.Font
	"Courier New"
	2:"10/1"
decimalTest:"50.23"
fractionTest:"4/52"
stringTest:"hello"
stringTest.6:stringTest.1
helloh:"hi"
stringStrategyHashTest:[stringTest]
x:
	aLongText:"
		hello world!
		hello!
		"
ored:bitwise.Disjunction
	"20"
	System.Windows.Forms.Keys.Tab
arrayList:System.Collections.ArrayList*
arrayList.Add 
	"hello"
arrayListResult:arrayList.0
textBox:System.Windows.Forms.TextBox*
textBox.Text.set
	"
		Alle meine Entchen,
		schwimmen auf dem See,
		schwimmen auf dem See,
		Köpfchen in das Wasser,
		Schwaenzchen in die Hoeh."
lines:textBox.Lines.get*
alleMeineText:lines.1
lines.5:"bwuhahaha"
tabText:"			hello"
escapedText:"\'\n\\\t"
whileCounter:*
loop:
	'
		whileDecision:Negation Equality
			arg
			"10"
		whileBranches:
			1:
				'loop Sum
					arg
					"1"
				 
			0:
				'arg
		this:whileBranches.[whileDecision] arg
whileCounter:loop "3"

	
returnInMap:
					
	'
		result:arg
literalAsArgument:returnInMap "1"				   
returnFunction:
	'
		'"functionResult"
returnArg:
	'arg
myArg:
	'
		hello:"world"
funcReturnTest:returnArg myArg*
documentedFunction:
	doc:"This function returns 'hello ."
	'"hello"
docFunctionResult:documentedFunction*
// end comment