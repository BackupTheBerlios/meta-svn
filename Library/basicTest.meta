#	Meta is a programming language.
#	Copyright (C) 2004 Christian Staudenmeyer <christianstaudenmeyer@web.de>
#
#	This program is free software; you can redistribute it and/or
#	modify it under the terms of the GNU General Public License version 2
#	as published by the Free Software Foundation.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
current=map.Merging
	parent
	=
		<AssignedToCurrent>
unicodeText=<äaba>
current=map.Merging
	parent
	logic
	map
	math
	array
internetTest=web.localhost.test
parent.parent.testSubDir.x=*
persistantDeleteTest=testSubDir.x
parent.parent.testSubDir.x=
	a=<b>
	x=
		x=<hello>
		y=<world>
integerHashTest=
	2=<correct hash content>
	hashTestData=
		[*]=
			[*]=*
	hashTest=[hashTestData]
negativeInteger=<-100>
negativeInteger.x=<hello>
subtractionTest=math.Sum
	<-100>
	Opposite <1000>
integerIncrementTest=<5>
integerIncrementTest.0=integerIncrementTest
integerDecrementTest=<5>
integerDecrementTest=integerDecrementTest.0
persistenceTest=testSubDir
literalEscapeTest=
	1=\<asdf>\
	2=\\<asdf>\\
	3=\\<as>\df>\\
	4=\\\<as>\\df>\\\
	5=\\\\\\\\\\\\\\\\\<as>\\\\\\\\\\\\\\\\df>\\\\\\\\\\\\\\\\\
applyMethod=
	|Sum
		parameter
		<1>
applyTest=Application
	function=applyMethod
	array=
		<1>
		<2>
		<3>
ifTestCondition=Equality
	<1>
	<1>
ifTestCases=
	1=
		|<it is true>
	0=
		|<it is false>
ifTest=ifTestCases.[ifTestCondition]*
#ifTest=If
#	condition=Equal
#		<1>
#		<1>
#	then=
#		|<it is true>
#	else=
#		|<it is false>
<ImpliedAutokey>
=<Autokey>
gacTest=System.Collections

	#some comment
lazyGACTest=Microsoft.CSharp
#metaLibTest=metaLib
commandLineArguments=parameter
#libraryAssemblyTest=testClasses
	#	asdfasdf	fff
#thisIsInAComment|
	#  still comment
# some more comment
aMap=
	[<a>]=<a>
[aMap]=<Object>
[<normal symbol>]=<NormalSymbol>
lookupSymbol=<LookupSymbol>
[<long key symbol>]=<LookupExtendedSymbol>
lookedUpMap=[aMap]
lookedUpNormalSymbol=[<normal symbol>]
lookedUpSymbol=lookupSymbol
lookedUpLongSymbol=[<long key symbol>]
object=
	a=<default>
	autoSearch=<default>
	b=*
	SetA=
		|
			parent.parent.a=<c>
			parent.parent.autoSearch=<changed>
	SetB=
		|
			parent.parent.b.1=parameter.value
			current=<changed>
	x=
		a=<b>
		c=<d>
	=
		|
			current.a=<b>
a=<default>
b=*
aSet=object.SetA*
bSet=object.SetB
	value=
		x=<7>
		z=<1>
ReturnEverything=
	|
		current=parameter
everythingReturned=ReturnEverything
	<a>
	<b>
	<c>
variableAsArgument=ReturnEverything
	<x>
	<y>
	<z>
ReturnFunction=
	|
		current=
			|
				current=
					<1>
					<2>
					<3>
SetCurrent=
	|
		current=
			parameter=parameter
			x=parameter.symbol
		current=x
thisSet=SetCurrent
	symbol=<haha>
FirstLevel=
	|
		SecondLevel parameter
SecondLevel=
	|parameter
argTest=FirstLevel
	a=<z>
concatenate=array.Concatenation
	<x>
	<yz>
current=map.Merging
	parent
	testClasses
TestClass.NestedClass.field=<5>
nestedClassTest=TestClass.NestedClass.field
testClass=TestClass*
testClass.floatValue=<1/3>
testClass.doubleValue=<1/3>
testClass.decimalValue=<1/3>
TestClass.boolTest=<1>
boolTest=TestClass.boolTest
memberTest=MemberTest*
MemberTest.classField=<a>
memberTest.instanceField=<b>
MemberTest.ClassProperty.Set
	memberTest.InstanceProperty.Get*
classPropertyValue=MemberTest.ClassProperty.Get*
memberTest.InstanceProperty.Set
	MemberTest.ClassProperty.Get*
instancePropertyValue=memberTest.InstanceProperty.Get*
interceptedSymbol=</hello/>
positionalNoConversion=PositionalNoConversion
	<m>
	<n>
	<o>
positionalNoConversionConcatenated=positionalNoConversion.Concatenate
	<r>
	<s>
	<t>
namedNoConversion=NamedNoConversion
	=
		<m>
		y=<n>
namedNoConversionConcatenated=namedNoConversion.Concatenate
	=
		c=<t>
		<r>
indexerNoConversion=IndexerNoConversion*
indexerNoConversion.abc=<hihi>
indexerNoConversionIndexed=indexerNoConversion.abc
interceptedSymbol2=<1>
k=<hello>
xyz=<w>
literalFunction=
	|<5>
literalFunctionResult=literalFunction*
someFunction=
	|
		current=<simple function this>
callFunction=
	|someFunction
callFunctionResult=callFunction*
delayedFunction=
	|
		|
			x=<y>
delayedFunctionResult=delayedFunction *
value=<xyz>
selectionFunction=
	|value
selectionFunctionResult=selectionFunction *
bigInteger=<89383838383832839123497123047217340712340720347072304702340720347>
upperLevel=<unchanged>
SetUpperLevel=
	|
		parent.parent.upperLevel=parameter
ChangeUpperLevel=
	|
		SetUpperLevel <changed>
ChangeUpperLevel*
staticEventChanged=<0>
ChangeStaticEvent=
	|
		parent.parent.staticEventChanged=parameter
TestClass.staticEvent.Add
	=
		|
			ChangeStaticEvent <1>
			current=parameter.1
staticEvent=TestClass.staticEvent
TestClass.TakeDelegate
	=
		|<resultFromDelegate>
resultFromDelegate=TestClass.GetResultFromDelegate*
staticEventResult=TestClass.staticEvent 
	testClass
instanceEventChanged=<0>
testClass.instanceEvent.Add
	=
		|
			parent.parent.parent.instanceEventChanged=<1>
			current=parameter.1
instanceEvent=testClass.instanceEvent
instanceEventResult=testClass.instanceEvent
	<5>
one=<1>
two=<2>
firstIf=<unchanged>
secondIf=<unchanged>
firstIfCondition=Equality
	<1>
	one
firstIfBranches=
	1=
		|<then>
	0=
		|<else>
firstIf=firstIfBranches.[firstIfCondition]*
bigNumber=<50020202029029233344>
secondSwitch=<unchanged>
secondSwitchCases=
	1=<one>
	2=<two>
	3=<three>
secondSwitch=secondSwitchCases.3
emptyMap=*
emptyFunction=
	|
		x=<hello>
emptyFunctionResult=emptyFunction*
font=System.Drawing.Font
	<Courier New>
	2=<10/1>
decimalTest=<50.23>
fractionTest=<4/52>
stringTest=<hello>
stringTest.6=stringTest.1
helloh=<hi>
stringStrategyHashTest=[stringTest]
x=
	aLongText=<
		hello world!
		hello!
		>
ored=bitwise.Disjunction
	<20>
	System.Windows.Forms.Keys.Tab
arrayList=System.Collections.ArrayList*
arrayList.Add 
	<hello>
arrayListResult=arrayList.0
textBox=System.Windows.Forms.TextBox*
textBox.Text.Set
	<
		Alle meine Entchen,
		schwimmen auf dem See,
		schwimmen auf dem See,
		Köpfchen in das Wasser,
		Schwaenzchen in die Hoeh.>
lines=textBox.Lines.Get*
alleMeineText=lines.1
lines.5=<bwuhahaha>
tabText=<			hello>
escapedText=<\'\n\\\t>
whileCounter=*
loop=
	|
		whileDecision=Negation Equality
			parameter
			<10>
		whileBranches=
			1=
				|loop Sum
					parameter
					<1>
				 
			0=
				|parameter
		current=whileBranches.[whileDecision] parameter
whileCounter=loop <3>

	
returnInMap=
					
	|
		result=parameter
literalAsArgument=returnInMap <1>				   
returnFunction=
	|
		|<functionResult>
returnArg=
	|parameter
myArg=
	|
		hello=<world>
funcReturnTest=returnArg myArg*
documentedFunction=
	doc=<This function returns 'hello .>
	|<hello>
docFunctionResult=documentedFunction*
# end comment
