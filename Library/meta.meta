|sdl.test*
license='"
	Meta is a programming language.
	Copyright (C) 2004 Christian Staudenmeyer "christianstaudenmeyer@web.de"

	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License version 2
	as published by the Free Software Foundation.

	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.

	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine*
file=
	write=
		|
			writer=mscorlib.StreamWriter
				arg.file
			writer.Write
				arg.text
			writer.Close*
sdl=
	test=
		|
			current=SdlDotNet
			Video.SetVideoModeWindow
				400
				300
			quit=*
			Events.Quit.add
				=
					|
						parent.parent.parent.quit=1
			library.map.while
				condition=
					|library.logic.not quit
				function=
					|Events.Poll*
html=
	tags=
		create=
			|
				name=arg
				|map.join
					"<"
					name
					">"
					arg
					"</"
					name
					">"
		|map.merge library.map.apply
			function=
				|
					[arg]=create arg
			array=
				"html"
				"head"
				"title"
				"body"
				"h1"
				"h2"
				"h3"
				"h4"
				"h5"
				"h6"
				"p"
				"br"
				"pre"
				"b"
				"i"
				"table"
				"tr"
				"td"
	table=
		|
			tags=tags*
			current=tags.table library.map.join library.map.apply
				array=arg
				function=
					|tags.tr map.join library.map.apply
						array=arg
						function=
							|tags.td arg
	test=
		|
			tags=tags*
			text=tags.html map.join
				tags.head tags.title "Meta rocks!"
				tags.body map.join
					tags.h1 "caption"
					tags.p "paragraph"
					tags.p "paragraph"
					table
						=
							"caption"
							"caption"
						=
							"data"
							"data"
						=
							"data"
							"data"
			display text
	display=
		|
			file.write
				file="C:\test.html"
				text=arg
			process=System.Process*
			startInfo=process.StartInfo.get*
			startInfo.FileName.set
				"iexplore.exe"
			startInfo.Arguments.set
				"C:\test.html"
			process.Start*
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			[1]='"asdf"'
			[2]=''"asdf"''
			[3]=''"as"'df"''
			[4]='''"as"''df"'''
			[5]='''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		="Autokey"
		commandLineArguments=arg
		aMap=
			["a"]="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA*
		bSet=object.SetB
			value=
				x=7
				z=1
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass*
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest*
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get*
		classPropertyValue=MemberTest.ClassProperty.get*
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get*
		instancePropertyValue=memberTest.InstanceProperty.get*
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion*
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction*
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction*
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		bigInteger=89383838383832839123497123047217340712340720347072304702340720347
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel*
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|"resultFromDelegate"
		resultFromDelegate=TestClass.GetResultFromDelegate*
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			[1]=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition]*
		bigNumber=50020202029029233344
		secondSwitch="unchanged"
		secondSwitchCases=
			[1]="one"
			[2]="two"
			[3]="three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction*
		font=["System.Drawing"].Font
			"Courier New"
			[2]=10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=["mscorlib"].ArrayList*
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox*
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get*
		alleMeineText=lines.[1]
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					[1]=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg*
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction*
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	map=
		while=
			|
				stop=arg.condition*
				next=
					[*]=
						|*
					[1]=
						|
							arg.function*
							while arg
				next.[stop] arg
		apply=
			|applyImplementation
				array=arg.array
				function=arg.function
				index=1
				result=*
			applyImplementation=
				|
					stop=library.math.greater
						arg.index
						library.map.length arg.array
					next=
						[1]=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								function=arg.function
								index=library.math.add
									arg.index
									1
								result=library.map.join
									arg.result
									=
										arg.function arg.array.[arg.index]
					current=next.[stop] arg
		join=
			|Meta.Interpreter.Join
				arg
		contains=
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			|
				object=Meta.ObjectMap
					arg
				current=Meta.Transform.ToMap
					object.Keys.get*
		merge=
			|Meta.Interpreter.Merge
				arg
		equal=
			|
				result=library.map.sum
					array=arg
					function=
						|
							first=Meta.ObjectMap
								arg.a.previous
							current=
								equality=library.logic.and
									first.Equals
										arg.b
									arg.a.equality
								previous=arg.b
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			|
				map=Meta.ObjectMap
					arg
				array=map.Array.get*
				current=array.Count.get*
		sum=
			|sumImplementation
				index=1
				array=arg.array
				function=arg.function
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						[1]=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.function
									a=arg.result
									b=arg.array.[arg.index]
								array=arg.array
								function=arg.function
					current=next.[stop] arg
	logic=
		not=
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			|library.map.sum
				array=arg
				function=
					|library.logic.and.table.[arg]
				start=1
			table=
				[
					a=1
					b=*
				]=*
				[
					a=*
					b=1
				]=*
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
		or=
			|library.map.sum
				array=arg
				function=
					|library.logic.or.table.[arg]
				start=*
			table=
				[
					a=1
					b=*
				]=1
				[
					a=*
					b=1
				]=1
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
	math=
		increment=
			|
				incremented=*
				incremented.[*]=arg
				current=incremented
		add=
			|Meta.NormalMap
				library.map.sum
					array=arg
					function=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
		multiply=
			|Meta.NormalMap
				library.map.sum
					array=arg
					function=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=1
		greater=
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			|Meta.NormalMap
				map.sum
					array=arg
					function=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|library.math.add
							arg
							1
					current=library.map.apply
						function=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|library.math.smaller
								counter
								10
						function=
							|SetCounter library.math.increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
editor=
	|
		current=library.map.merge
			parent
			System
			mscorlib
			["System.Windows.Forms"]
			["System.Drawing"]
			Meta
			library.logic
			library.map
			library.math
			Editor
		Process=Meta.Process
		SetBreakPoint=
			|process.BreakPoint.set
				BreakPoint
					SourcePosition
						add
							editBox.LineIndex.get*
							1
						add
							editBox.Column.get*
							1
		process=Process*
		commands=
			Save=
				|FileSystem.Set
					editBox.RealText.get*
			Start=
				|
					parent.parent.parent.process=Process*
					commands.Save*
					SetBreakPoint*
					process.Break.add
						=
							|editBox.ShowDebugValue
								arg.[1]
					process.Start*
			Continue=
				|
					SetBreakPoint*
					process.Reversed.set
						*
					process.Continue*
			Reverse=
				|
					SetBreakPoint*
					process.Reversed.set
						1
					process.Continue*
			Stop=
				|
					process.Stop*
		CombinedModifierKeys=
			current=["System.Windows.Forms"]
			AltControl=library.bitwise.or
				Keys.Alt
				Keys.Control
			AltShift=library.bitwise.or
				Keys.Alt
				Keys.Shift
			AltControlShift=library.bitwise.or
				Keys.Alt
				Keys.Control
				Keys.Shift
			ControlShift=library.bitwise.or
				Keys.Control
				Keys.Shift
		shortcutCombinations=
			current=["System.Windows.Forms"]
			[Keys.None]=
				[Keys.Escape]=
					|editBox.StopInteractiveSearch*
				[Keys.F5]=
					|commands.Start*
				[Keys.Up]=
					|editBox.MoveLineUp*
				[Keys.Down]=
					|editBox.MoveLineDown*
				[Keys.Left]=
					|editBox.MoveCharLeft*
				[Keys.Right]=
					|editBox.MoveCharRight*
				[Keys.Home]=
					|editBox.MoveLineStart*
				[Keys.End]=
					|editBox.MoveLineEnd*
				[Keys.Tab]=
					|editBox.IncreaseSelectionIndent*
				[Keys.Back]=
					|editBox.DeleteCharLeft*
				[Keys.Delete]=
					|editBox.DeleteCharRight*
				[Keys.PageUp]=
					|editBox.MovePageUp*
				[Keys.PageDown]=
					|editBox.MovePageDown*
			[Keys.Shift]=
				[Keys.Left]=
					|editBox.SelectCharLeft*
				[Keys.Right]=
					|editBox.SelectCharRight*
			[Keys.Control]=
				[Keys.S]=
					|commands.Save*
				[Keys.I]=
					|editBox.StartInteractiveSearch*
				[Keys.H]=
					|editBox.FindAndReplace*
				[Keys.Left]=
					|editBox.MoveWordLeft*
				[Keys.Right]=
					|editBox.MoveWordRight*
				[Keys.Back]=
					|editBox.DeleteWordLeft*
				[Keys.Delete]=
					|editBox.DeleteWordRight*
				[Keys.Home]=
					|editBox.MoveDocumentStart*
				[Keys.End]=
					|editBox.MoveDocumentEnd*
			[Keys.Alt]=
				[Keys.K]=
					|editBox.MoveLineDown*
				[Keys.L]=
					|editBox.MoveLineUp*
				[Keys.Oemtilde]=
					|editBox.MoveCharRight*
				[Keys.J]=
					|editBox.MoveCharLeft*
				[Keys.U]=
					|editBox.MoveLineStart*
				[Keys.OemSemicolon]=
					|editBox.MoveLineEnd*
				[Keys.N]=
					|editBox.DeleteCharLeft*
				[Keys.M]=
					|editBox.DeleteCharRight*
			[CombinedModifierKeys.ControlShift]=
				[Keys.Left]=
					|editBox.SelectWordLeft*
				[Keys.Right]=
					|editBox.SelectWordRight*
			[CombinedModifierKeys.AltShift]=
				[Keys.J]=
					|editBox.SelectCharLeft*
				[Keys.Oemtilde]=
					|editBox.SelectCharRight*
				[Keys.L]=
					|editBox.SelectLineUp*
				[Keys.K]=
					|editBox.SelectLineDown*
				[Keys.OemSemicolon]=
					|editBox.SelectLineEnd*
				[Keys.U]=
					|editBox.SelectLineStart*
			[CombinedModifierKeys.AltControl]=
				[Keys.J]=
					|editBox.MoveWordLeft*
				[Keys.Oemtilde]=
					|editBox.MoveWordRight*
				[Keys.OemSemicolon]=
					|editBox.MoveDocumentEnd*
				[Keys.U]=
					|editBox.MoveDocumentStart*
				[Keys.N]=
					|editBox.DeleteWordLeft*
				[Keys.M]=
					|editBox.DeleteWordRight*
				[Keys.L]=
					|editBox.MovePageUp*
				[Keys.K]=
					|editBox.MovePageDown*
			[CombinedModifierKeys.AltControlShift]=
				[Keys.J]=
					|editBox.SelectWordLeft*
				[Keys.Oemtilde]=
					|editBox.SelectWordRight*
		editBox=
			editBox=ScrollingTextBox*
			editBox.ShowSelectionMargin.set
				1
			editBox.AcceptsTab.set
				1
			editBox.Dock.set
				DockStyle.Fill
			editBox.ScrollBars.set
				RichTextBoxScrollBars.ForcedBoth
			editBox.Moved.add
				=
					|
						cases=
							[*]=
								|commands.Reverse*
							[1]=
								|commands.Continue*
						breakpoint=process.BreakPoint.get*
						position=breakpoint.Position.get*
						line=position.Line.get*
						forward=smaller
							line
							editBox.LineIndex.get*
						cases.[forward]*
			editBox.KeyDown.add
				=
					|
						eventArgs=arg.[2]
						modifier=eventArgs.Modifiers.get*
						key=eventArgs.KeyCode.get*
						shortcuts=shortcutCombinations.[modifier]
						exists=contains
							map=shortcuts
							key=key
						cases=
							[1]=
								|
									editBox.SuspendWindowUpdate*
									shortcuts.[key]*
									editBox.ResumeWindowUpdate*
									eventArgs.Handled.set
										1
							[*]=
								|*
						cases.[exists]*
			editBox.RealText.set
				FileAccess.Read
					FileSystem.Path.get*
			current=editBox
		form=
			form=Form*
			form.Text.set
				"Meta Edit"
			form.Font.set
				Font
					"Courier New"
					10
			controls=form.Controls.get*
			controls.AddRange
				=
					editBox
			menu=
				File=
					Save=
						|commands.Save*
					Close=
						|form.Close*
				Debug=
					Start=
						|commands.Start*
					Continue=
						|commands.Continue*
					Reverse=
						|commands.Reverse*
					Stop=
						|commands.Stop*
			form.Menu.set
				MainMenu
					apply
						array=keys menu
						function=
							|
								topKey=arg
								current=MenuItem
									topKey
									apply
										array=keys menu.[topKey]
										function=
											|MenuItem
												arg
												menu.[topKey].[arg]
			current=form