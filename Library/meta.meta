#	Meta is a programming language.
#	Copyright (C) 2004 Christian Staudenmeyer "christianstaudenmeyer@web.de"
#
#	This program is free software; you can redistribute it and/or
#	modify it under the terms of the GNU General Public License version 2
#	as published by the Free Software Foundation.
#
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			[1]=\"asdf"\
			[2]=\\"asdf"\\
			[3]=\\"as"\df"\\
			[4]=\\\"as"\\df"\\\
			[5]=\\\\\\\\\\\\\\\\\"as"\\\\\\\\\\\\\\\\df"\\\\\\\\\\\\\\\\\
		"ImpliedAutokey"
		="Autokey"
		commandLineArguments=parameter
		aMap=
			["a"]="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=parameter.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA*
		bSet=object.SetB
			value=
				x=7
				z=1
		ReturnEverything=
			|
				current=parameter
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					parameter=parameter
					x=parameter.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel parameter
		SecondLevel=
			|parameter
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass*
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest*
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get*
		classPropertyValue=MemberTest.ClassProperty.get*
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get*
		instancePropertyValue=memberTest.InstanceProperty.get*
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion*
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction*
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction*
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		bigInteger=89383838383832839123497123047217340712340720347072304702340720347
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=parameter
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel*
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=parameter
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=parameter.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|"resultFromDelegate"
		resultFromDelegate=TestClass.GetResultFromDelegate*
		staticEventResult=TestClass.staticEvent 
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=parameter.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			[1]=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition]*
		bigNumber=50020202029029233344
		secondSwitch="unchanged"
		secondSwitchCases=
			[1]="one"
			[2]="two"
			[3]="three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction*
		font=["System.Drawing"].Font
			"Courier New"
			[2]=10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=["mscorlib"].ArrayList*
		arrayList.Add 
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox*
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get*
		alleMeineText=lines.[1]
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="\#\n\\\t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					parameter
					10
				whileBranches=
					[1]=
						|loop library.math.add
							parameter
							1
					[*]=
						|parameter
				current=whileBranches.[whileDecision] parameter
		whileCounter=loop 3
		returnInMap=
			|
				result=parameter
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|parameter
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg*
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction*
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	map=
		join=
			|Meta.Interpreter.Join
				parameter
		contains=
			|
				object=Meta.ObjectMap
					parameter.map
				current=object.ContainsKey
					parameter.key
		keys=
			|
				object=Meta.ObjectMap
					parameter
				current=Meta.Transform.ToMap
					object.Keys.get*
		merge=
			|Meta.Interpreter.Merge
				parameter
		equal=
			|Meta.Interpreter.Equal
				parameter
	logic=
		not=
			|table.[parameter]
			table=
				[*]=1
				[1]=*
		and=
			|Meta.Interpreter.And
				parameter
		or=
			|Meta.Interpreter.Or
				parameter
	math=
		add=
			|Meta.Interpreter.Add
				parameter
		multiply=
			|Meta.Interpreter.Multiply
				parameter
		greater=
			|Meta.Interpreter.Greater
				parameter
		smaller=
			|Meta.Interpreter.Smaller
				parameter
	bitwise=
		or=
			|Meta.Interpreter.BitwiseOr
				parameter
map=
	join=
		|Meta.Interpreter.Join
			parameter
	contains=
		|
			object=Meta.ObjectMap
				parameter.map
			current=object.ContainsKey
				parameter.key
	keys=
		|
			object=Meta.ObjectMap
				parameter
			current=Meta.Transform.ToMap
				object.Keys.get*
	merge=
		|Meta.Interpreter.Merge
			parameter
	equal=
		|Meta.Interpreter.Equal
			parameter
logic=
	not=
		|table.[parameter]
		table=
			[*]=1
			[1]=*
	and=
		|Meta.Interpreter.And
			parameter
	or=
		|Meta.Interpreter.Or
			parameter
math=
	add=
		|Meta.Interpreter.Add
			parameter
	multiply=
		|Meta.Interpreter.Multiply
			parameter
	greater=
		|Meta.Interpreter.Greater
			parameter
	smaller=
		|Meta.Interpreter.Smaller
			parameter
bitwise=
	or=
		|Meta.Interpreter.BitwiseOr
			parameter
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		booleanTest=
			not=
				true=not *
				false=not 1
			and=
				true=and
					1
					1
					1
					1
				false=and
					1
					*
					1
					1
			or=
				true=or
					1
					1
					1
				false=or
					*
					*
					*
		numberTest=
			add=add
				100
				1000
			multiply=multiply
				19
				1023
			greater=greater
				4
				1
			smaller=smaller
				23
				2
		bitwiseTest=
			or=library.bitwise.or
				8
				20
		mapTest=
			join=join
				"abc, "
				"die Katze lief im Schnee."
			apply=
				applyMethod=
					|add
						parameter
						1
				current=Library.map.apply
					function=applyMethod
					array=
						1
						2
						3
			contains=contains
				map=
					x="hello"
				key="x"
			keys=keys
				jjqwv="aeäquq"
				oere="i ke"
				"oiq"
			equal=
				numbers=equal
					1
					1
		bitwiseTest=library.bitwise.or
			20
			["System.Windows.Forms"].Keys.Tab
editor=
	|
		current=library.map.merge
			parent
			System
			mscorlib
			["System.Windows.Forms"]
			["System.Drawing"]
			Meta
			library.logic
			library.map
			library.math
			Library.map
			Editor
		file=
			Write=
				|
					writer=StreamWriter
						parameter.[1]
					writer.Write
						parameter.[2]
					writer.Close*
			Read=
				|
					reader=StreamReader
						parameter
					result=reader.ReadToEnd*
					reader.Close*
					current=result
		SetBreakPoint=
			|Meta.Interpreter.BreakPoint.set
				Meta.BreakPoint
					Meta.SourcePosition
						add
							editBox.LineIndex.get*
							1
						editBox.Column.get*
		commands=
			Save=
				|
					hasName=not Equality
						fileName
						*
					cases=
						[*]=
							|commands.SaveAs*
						[1]=
							|file.Write
								fileName
								editBox.RealText.get*
					cases.[hasName]*
			Open=
				|
					openFileName=choose.OpenFile*
					hasName=not Equality
						openFileName
						*
					cases=
						[*]=
							|*
						[1]=
							|
								SetFileName openFileName
								editBox.RealText.set
									file.Read fileName
								editBox.MoveAbsolute
									*
									*
					cases.[hasName]*
			Run=
				|
					commands.Save*
					SetBreakPoint*
					Meta.Interpreter.Break.add
						=
							|editBox.ShowDebugValue
								parameter.[1]
					Meta.Interpreter.StartDebug
						fileName
			Continue=
				|
					SetBreakPoint*
					Meta.Interpreter.ContinueDebug*
			Reverse=
				|
					SetBreakPoint*
					Meta.Interpreter.ReverseDebug*
			Stop=
				|Meta.Interpreter.StopDebug*
		CombinedModifierKeys=
			current=["System.Windows.Forms"]
			AltControl=library.bitwise.or
				Keys.Alt
				Keys.Control
			AltShift=library.bitwise.or
				Keys.Alt
				Keys.Shift
			AltControlShift=library.bitwise.or
				Keys.Alt
				Keys.Control
				Keys.Shift
			ControlShift=library.bitwise.or
				Keys.Control
				Keys.Shift
		shortcutCombinations=
			current=["System.Windows.Forms"]
			[Keys.None]=
				[Keys.Escape]=
					|editBox.StopInteractiveSearch*
				[Keys.F5]=
					|commands.Run*
				[Keys.F5]=
					|commands.Run*
				[Keys.Up]=
					|editBox.MoveLineUp*
				[Keys.Down]=
					|editBox.MoveLineDown*
				[Keys.Left]=
					|editBox.MoveCharLeft*
				[Keys.Right]=
					|editBox.MoveCharRight*
				[Keys.Home]=
					|editBox.MoveLineStart*
				[Keys.End]=
					|editBox.MoveLineEnd*
				[Keys.Tab]=
					|editBox.IncreaseSelectionIndent*
				[Keys.Back]=
					|editBox.DeleteCharLeft*
				[Keys.Delete]=
					|editBox.DeleteCharRight*
				[Keys.PageUp]=
					|editBox.MovePageUp*
				[Keys.PageDown]=
					|editBox.MovePageDown*
			[Keys.Shift]=
				[Keys.Left]=
					|editBox.SelectCharLeft*
				[Keys.Right]=
					|editBox.SelectCharRight*
			[Keys.Control]=
				[Keys.O]=
					|commands.Open*
				[Keys.S]=
					|commands.Save*
				[Keys.I]=
					|editBox.StartInteractiveSearch*
				[Keys.H]=
					|editBox.FindAndReplace*
				[Keys.Left]=
					|editBox.MoveWordLeft*
				[Keys.Right]=
					|editBox.MoveWordRight*
				[Keys.Back]=
					|editBox.DeleteWordLeft*
				[Keys.Delete]=
					|editBox.DeleteWordRight*
				[Keys.Home]=
					|editBox.MoveDocumentStart*
				[Keys.End]=
					|editBox.MoveDocumentEnd*
			[Keys.Alt]=
				[Keys.K]=
					|editBox.MoveLineDown*
				[Keys.L]=
					|editBox.MoveLineUp*
				[Keys.Oemtilde]=
					|editBox.MoveCharRight*
				[Keys.J]=
					|editBox.MoveCharLeft*
				[Keys.U]=
					|editBox.MoveLineStart*
				[Keys.OemSemicolon]=
					|editBox.MoveLineEnd*
				[Keys.N]=
					|editBox.DeleteCharLeft*
				[Keys.M]=
					|editBox.DeleteCharRight*
			[CombinedModifierKeys.ControlShift]=
				[Keys.Left]=
					|editBox.SelectWordLeft*
				[Keys.Right]=
					|editBox.SelectWordRight*
			[CombinedModifierKeys.AltShift]=
				[Keys.J]=
					|editBox.SelectCharLeft*
				[Keys.Oemtilde]=
					|editBox.SelectCharRight*
				[Keys.L]=
					|editBox.SelectLineUp*
				[Keys.K]=
					|editBox.SelectLineDown*
				[Keys.OemSemicolon]=
					|editBox.SelectLineEnd*
				[Keys.U]=
					|editBox.SelectLineStart*
			[CombinedModifierKeys.AltControl]=
				[Keys.J]=
					|editBox.MoveWordLeft*
				[Keys.Oemtilde]=
					|editBox.MoveWordRight*
				[Keys.OemSemicolon]=
					|editBox.MoveDocumentEnd*
				[Keys.U]=
					|editBox.MoveDocumentStart*
				[Keys.N]=
					|editBox.DeleteWordLeft*
				[Keys.M]=
					|editBox.DeleteWordRight*
				[Keys.L]=
					|editBox.MovePageUp*
				[Keys.K]=
					|editBox.MovePageDown*
			[CombinedModifierKeys.AltControlShift]=
				[Keys.J]=
					|editBox.SelectWordLeft*
				[Keys.Oemtilde]=
					|editBox.SelectWordRight*
		editBox=
			editBox=ScrollingTextBox*
			editBox.ShowSelectionMargin.set
				1
			editBox.AcceptsTab.set
				1
			editBox.Dock.set
				DockStyle.Fill
			editBox.ScrollBars.set
				RichTextBoxScrollBars.ForcedBoth
			editBox.Moved.add
				=
					|
						cases=
							[*]=
								|commands.Reverse*
							[1]=
								|commands.Continue*
						breakpoint=Meta.Interpreter.BreakPoint.get*
						position=breakpoint.Position.get*
						line=position.Line.get*
						forward=smaller
							line
							editBox.LineIndex.get*
						cases.[forward]*
			editBox.KeyDown.add
				=
					|
						eventArgs=parameter.[2]
						modifier=eventArgs.Modifiers.get*
						key=eventArgs.KeyCode.get*
						shortcuts=shortcutCombinations.[modifier]
						exists=Containment
							map=shortcuts
							key=key
						cases=
							[1]=
								|
									editBox.SuspendWindowUpdate*
									shortcuts.[key]*
									editBox.ResumeWindowUpdate*
									eventArgs.Handled.set
										1
							[*]=
								|*
						cases.[exists]*
			current=editBox
		form=
			form=Form*
			form.Text.set
				"Meta Edit"
			form.Font.set
				Font
					"Courier New"
					10
			controls=form.Controls.get*
			controls.AddRange
				=
					editBox
			menu=
				File=
					["Open..."]=commands.Open
					["Save"]=commands.Save
					["Save as..."]=commands.SaveAs
					["Close"]=
						|form.Close*
				Debug=
					Start=commands.Run
					Continue=commands.Continue
					Reverse=commands.Reverse
					Stop=commands.Stop
			form.Menu.set
				MainMenu
					apply
						array=keys menu
						function=
							|
								topKey=parameter
								current=MenuItem
									topKey
									apply
										array=keys menu.[topKey]
										function=
											|MenuItem
												parameter
												menu.[topKey].[parameter]
			current=form
		form.ShowDialog*