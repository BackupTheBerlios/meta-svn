|market *
license='"
	Meta is a programming language.
	Copyright (C) 2004 Christian Staudenmeyer "christianstaudenmeyer@web.de"
	
	This program is free software; you can redistribute it and/or
	modify it under the terms of the GNU General Public License version 2
	as published by the Free Software Foundation.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program; if not, write to the Free Software
	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA."'
debugTest=
	|
		abc="hello"
		map=
			a="hello"
			b="world"
			aha=
				thisStuff=
					"rocks"
			absolutely="!!!!"
		map="x"
		x=abc
		asdfasdf=map
		mscorlib.Console.WriteLine
			"hello world"
		mscorlib.Console.ReadLine *
file=
	write=
		|
			writer=mscorlib.StreamWriter
				arg.file
			writer.Write
				arg.text
			writer.Close *
sdl=
	test=
		|
			current=SdlDotNet
			Video.SetVideoModeWindow
				400
				300
			quit=*
			Events.Quit.add
				=
					|
						parent.parent.parent.quit=1
			library.map.while
				condition=
					|library.logic.not quit
				with=
					|Events.Poll *
basicTest=
	|
		current=library.map.merge
			parent
			=
				"AssignedToCurrent"
		scoping=
			test=
				scopingValue="right"
				|scopingValue
		scopingValue="wrong"
		scopingTest=scoping.test
		lexicalScoping=scopingTest *
		unicodeText="äaba"
		parent.parent.testSubDir.x=*
		persistantDeleteTest=testSubDir.x
		parent.parent.testSubDir.x=
			a="b"
			x=
				x="hello"
				y="world"
		integerHashTest=
			[2]="correct hash content"
			hashTestData=
				[*]=
					[*]=*
			hashTest=[hashTestData]
		negativeInteger=100
		negativeInteger.x="hello"
		integerIncrementTest=5
		integerIncrementTest.[*]=integerIncrementTest
		integerDecrementTest=5
		integerDecrementTest=integerDecrementTest.[*]
		persistenceTest=testSubDir
		literalEscapeTest=
			"asdf"
			"asdf"
			''"as"'df"''
			'''"as"''df"'''
			'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
		"ImpliedAutokey"
		"Autokey"
		commandLineArguments=arg
		aMap=
			a="a"
		[aMap]="Object"
		["normal symbol"]="NormalSymbol"
		lookupSymbol="LookupSymbol"
		["long key symbol"]="LookupExtendedSymbol"
		lookedUpMap=[aMap]
		lookedUpNormalSymbol=["normal symbol"]
		lookedUpSymbol=lookupSymbol
		lookedUpLongSymbol=["long key symbol"]
		object=
			a="default"
			autoSearch="default"
			b=*
			SetA=
				|
					parent.parent.a="c"
					parent.parent.autoSearch="changed"
			SetB=
				|
					parent.parent.b.[1]=arg.value
					current="changed"
			x=
				a="b"
				c="d"
			=
				|
					current.a="b"
		a="default"
		b=*
		aSet=object.SetA *
		bSet=object.SetB
			value=
				x=7
				z=1
		ReturnEverything=
			|
				current=arg
		everythingReturned=ReturnEverything
			"a"
			"b"
			"c"
		variableAsArgument=ReturnEverything
			"x"
			"y"
			"z"
		ReturnFunction=
			|
				current=
					|
						current=
							1
							2
							3
		SetCurrent=
			|
				current=
					arg=arg
					x=arg.symbol
				current=x
		thisSet=SetCurrent
			symbol="haha"
		FirstLevel=
			|
				SecondLevel arg
		SecondLevel=
			|arg
		argTest=FirstLevel
			a="z"
		TestClass=MetaTest.TestClass
		TestClass.NestedClass.field=5
		nestedClassTest=TestClass.NestedClass.field
		testClass=TestClass *
		testClass.floatValue=3
		testClass.doubleValue=4
		testClass.decimalValue=5
		TestClass.boolTest=1
		boolTest=TestClass.boolTest
		MemberTest=MetaTest.MemberTest
		memberTest=MemberTest *
		MemberTest.classField="a"
		memberTest.instanceField="b"
		MemberTest.ClassProperty.set
			memberTest.InstanceProperty.get *
		classPropertyValue=MemberTest.ClassProperty.get *
		memberTest.InstanceProperty.set
			MemberTest.ClassProperty.get *
		instancePropertyValue=memberTest.InstanceProperty.get *
		interceptedSymbol="/hello/"
		positionalNoConversion=MetaTest.PositionalNoConversion
			"m"
			"n"
			"o"
		positionalNoConversionConcatenated=positionalNoConversion.Concatenate
			"r"
			"s"
			"t"
		namedNoConversion=MetaTest.NamedNoConversion
			=
				"m"
				y="n"
		namedNoConversionConcatenated=namedNoConversion.Concatenate
			=
				c="t"
				"r"
		indexerNoConversion=MetaTest.IndexerNoConversion *
		indexerNoConversion.Item.set
			"abc"
			"hihi"
		indexerNoConversionIndexed=indexerNoConversion.Item.get
			"abc"
		interceptedSymbolTwo=1
		k="hello"
		xyz="w"
		literalFunction=
			|5
		literalFunctionResult=literalFunction *
		someFunction=
			|
				current="simple function this"
		callFunction=
			|someFunction
		callFunctionResult=callFunction *
		delayedFunction=
			|
				|
					x="y"
		delayedFunctionResult=delayedFunction *
		value="xyz"
		selectionFunction=
			|value
		selectionFunctionResult=selectionFunction *
		"bigInteger=89383838383832839123497123047217340712340720347072304702340720347"
		upperLevel="unchanged"
		SetUpperLevel=
			|
				parent.parent.upperLevel=arg
		ChangeUpperLevel=
			|
				SetUpperLevel "changed"
		ChangeUpperLevel *
		staticEventChanged=*
		ChangeStaticEvent=
			|
				parent.parent.staticEventChanged=arg
		TestClass.staticEvent.add
			=
				|
					ChangeStaticEvent 1
					current=arg.[1]
		staticEvent=TestClass.staticEvent
		TestClass.TakeDelegate
			=
				|arg.[1]
		resultFromDelegate=TestClass.GetResultFromDelegate *
		staticEventResult=TestClass.staticEvent
			testClass
		instanceEventChanged=*
		testClass.instanceEvent.add
			=
				|
					parent.parent.parent.instanceEventChanged=1
					current=arg.[1]
		instanceEvent=testClass.instanceEvent
		instanceEventResult=testClass.instanceEvent
			5
		one=1
		two=2
		firstIf="unchanged"
		secondIf="unchanged"
		firstIfCondition=library.map.equal
			1
			one
		firstIfBranches=
			=
				|"then"
			[*]=
				|"else"
		firstIf=firstIfBranches.[firstIfCondition] *
		bigNumber=50020202029029233344
		secondSwitch="unchanged"
		secondSwitchCases=
			"one"
			"two"
			"three"
		secondSwitch=secondSwitchCases.[3]
		emptyMap=*
		emptyFunction=
			|
				x="hello"
		emptyFunctionResult=emptyFunction *
		font=["System.Drawing"].Font
			"Courier New"
			10
		decimalTest=5
		fractionTest=40
		stringTest="hello"
		stringTest.[6]=stringTest.[1]
		helloh="hi"
		stringStrategyHashTest=[stringTest]
		x=
			aLongText="
				hello world!
				hello!
				"
		arrayList=mscorlib.ArrayList *
		arrayList.Add
			"hello"
		arrayListResult=arrayList.Item.get
			*
		textBox=["System.Windows.Forms"].TextBox *
		textBox.Text.set
			"
				Alle meine Entchen,
				schwimmen auf dem See,
				schwimmen auf dem See,
				Köpfchen in das Wasser,
				Schwaenzchen in die Hoeh."
		lines=textBox.Lines.get *
		alleMeineText=lines.[1]
		lines.[5]="bwuhahaha"
		tabText="			hello"
		escapedText="'#'n'''t"
		whileCounter=*
		loop=
			|
				whileDecision=library.logic.not library.map.equal
					arg
					10
				whileBranches=
					=
						|loop library.math.add
							arg
							1
					[*]=
						|arg
				current=whileBranches.[whileDecision] arg
		whileCounter=loop 3
		returnInMap=
			|
				result=arg
		literalAsArgument=returnInMap 1
		returnFunction=
			|
				|"functionResult"
		returnArg=
			|arg
		myArg=
			|
				hello="world"
		funcReturnTest=returnArg myArg *
		documentedFunction=
			doc="This function returns #hello ."
			|"hello"
		docFunctionResult=documentedFunction *
testSubDir=
	testLib=
		x="hello"
		y="world"
		subMap=
			a="b"
			c="d"
	x=
		a="b"
		x=
			x="hello"
			y="world"
library=
	map=
		while=
			|
				stop=arg.condition *
				next=
					[*]=
						|*
					=
						|
							arg.with *
							while arg
				next.[stop] arg
		apply=
			|applyImplementation
				array=arg.array
				with=arg.with
				index=1
				result=*
			applyImplementation=
				|
					stop=library.math.greater
						arg.index
						library.map.length arg.array
					next=
						=
							|arg.result
						[*]=
							|applyImplementation
								array=arg.array
								with=arg.with
								index=library.math.add
									arg.index
									1
								object=Meta.ObjectMap
									arg.result
								argument=arg.with arg.array.[arg.index]
								object.Append
									argument
								result=object.Current.get *
					current=next.[stop] arg
		join=
			|library.map.sum
				array=arg
				with=
					|
						joined=Meta.ObjectMap
							arg.a
						apply
							array=arg.b
							with=
								|joined.Append
									arg
						current=joined.Current.get *
				start=*
		contains=
			|
				object=Meta.ObjectMap
					arg.map
				current=object.ContainsKey
					arg.key
		keys=
			|
				object=Meta.ObjectMap
					arg
				current=Meta.NormalMap
					object.Keys.get *
		merge=
			|sum
				array=arg
				with=
					|
						overwrite=arg.b
						current=sum
							array=keys arg.b
							with=
								|
									result=arg.a
									result.[arg.b]=overwrite.[arg.b]
									current=result
							start=arg.a
				start=*
		equal=
			|
				result=library.map.sum
					array=arg
					with=
						|
							first=Meta.ObjectMap
								arg.a.previous
							current=
								equality=library.logic.and
									first.Equals
										arg.b
									arg.a.equality
								previous=arg.b
					start=
						equality=1
						previous=arg.[1]
				current=result.equality
		length=
			|
				map=Meta.ObjectMap
					arg
				array=map.Array.get *
				current=array.Count.get *
		sum=
			|sumImplementation
				index=1
				array=arg.array
				with=arg.with
				result=arg.start
			sumImplementation=
				|
					stop=math.greater
						arg.index
						length arg.array
					next=
						=
							|arg.result
						[*]=
							|sumImplementation
								index=math.increment arg.index
								result=arg.with
									a=arg.result
									b=arg.array.[arg.index]
								array=arg.array
								with=arg.with
					current=next.[stop] arg
	logic=
		not=
			|table.[arg]
			table=
				[*]=1
				[1]=*
		and=
			|library.map.sum
				array=arg
				with=
					|library.logic.and.table.[arg]
				start=1
			table=
				[
					a=1
					b=*
				]=*
				[
					a=*
					b=1
				]=*
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
		or=
			|library.map.sum
				array=arg
				with=
					|library.logic.or.table.[arg]
				start=*
			table=
				[
					a=1
					b=*
				]=1
				[
					a=*
					b=1
				]=1
				[
					a=*
					b=*
				]=*
				[
					a=1
					b=1
				]=1
	math=
		increment=
			|
				result=Meta.Integer.op_Addition
					Meta.Integer
						arg
					Meta.Integer
						1
				current=Meta.NormalMap
					result
		add=
			|Meta.NormalMap
				library.map.sum
					array=arg
					with=
						|Meta.Integer.op_Addition
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
		multiply=
			|Meta.NormalMap
				library.map.sum
					array=arg
					with=
						|Meta.Integer.op_Multiply
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=1
		greater=
			|Meta.Integer.op_GreaterThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
		smaller=
			|Meta.Integer.op_LessThan
				Meta.Integer
					arg.[1]
				Meta.Integer
					arg.[2]
	bitwise=
		or=
			|Meta.NormalMap
				map.sum
					array=arg
					with=
						|Meta.Integer.op_BitwiseOr
							Meta.Integer
								arg.a
							Meta.Integer
								arg.b
					start=*
libraryTest=
	|
		current=library.map.merge
			parent
			library.map
			library.logic
			library.math
		test=
			booleanTest=
				not=
					true=not *
					false=not 1
				and=
					true=and
						1
						1
						1
						1
					false=and
						1
						*
						1
						1
				or=
					true=or
						1
						1
						1
					false=or
						*
						*
						*
			numberTest=
				increment=increment 5
				add=add
					100
					1000
				multiply=multiply
					19
					1023
				greater=greater
					4
					1
				smaller=smaller
					23
					2
			bitwiseTest=
				or=library.bitwise.or
					8
					20
			mapTest=
				join=join
					"abc, "
					"die Katze lief im Schnee."
				apply=
					applyMethod=
						|library.math.add
							arg
							1
					current=library.map.apply
						with=applyMethod
						array=
							1
							2
							3
				contains=contains
					map=
						x="hello"
					key="x"
				keys=keys
					jjqwv="aeäquq"
					oere="i ke"
					"oiq"
				equal=
					map=
						true=equal
							=
								x="hello"
								y="world"
							=
								x="hello"
								y="world"
						false=equal
							=
								x="y"
								y="z"
							=
								x="y"
								y="a"
				while=
					counter=*
					SetCounter=
						|
							parent.parent.counter=arg
					test=while
						condition=
							|library.math.smaller
								counter
								10
						with=
							|SetCounter library.math.increment counter
					current=counter
			bitwiseTest=library.bitwise.or
				20
				["System.Windows.Forms"].Keys.Tab
		current=test
editor=
	|
		Process=Meta.Process
		SetBreakPoint=
			|process.BreakPoint.set
				Meta.SourcePosition
					library.math.add
						editBox.LineIndex.get *
						1
					library.math.add
						editBox.Column.get *
						1
		process=Process *
		commands=
			Save=
				|Meta.LocalStrategy.Set
					editBox.RealText.get *
			Start=
				|
					parent.parent.parent.process=Process *
					commands.Save *
					SetBreakPoint *
					process.Break.add
						=
							|editBox.ShowDebugValue
								arg.[1]
					process.Start *
			Continue=
				|
					SetBreakPoint *
					process.ReverseDebugging.set
						*
					process.Continue *
			Reverse=
				|
					SetBreakPoint *
					process.ReverseDebugging.set
						1
					process.Continue *
			Stop=
				|
					process.Stop *
		CombinedModifierKeys=
			forms=["System.Windows.Forms"]
			AltControl=library.bitwise.or
				forms.Keys.Alt
				forms.Keys.Control
			AltShift=library.bitwise.or
				forms.Keys.Alt
				forms.Keys.Shift
			AltControlShift=library.bitwise.or
				forms.Keys.Alt
				forms.Keys.Control
				forms.Keys.Shift
			ControlShift=library.bitwise.or
				forms.Keys.Control
				forms.Keys.Shift
		shortcutCombinations=
			forms=["System.Windows.Forms"]
			[forms.Keys.None]=
				[forms.Keys.Escape]=
					|editBox.StopInteractiveSearch *
				[forms.Keys.F5]=
					|commands.Start *
				[forms.Keys.Up]=
					|editBox.MoveLineUp *
				[forms.Keys.Down]=
					|editBox.MoveLineDown *
				[forms.Keys.Left]=
					|editBox.MoveCharLeft *
				[forms.Keys.Right]=
					|editBox.MoveCharRight *
				[forms.Keys.Home]=
					|editBox.MoveLineStart *
				[forms.Keys.End]=
					|editBox.MoveLineEnd *
				[forms.Keys.Tab]=
					|editBox.IncreaseSelectionIndent *
				[forms.Keys.Back]=
					|editBox.DeleteCharLeft *
				[forms.Keys.Delete]=
					|editBox.DeleteCharRight *
				[forms.Keys.PageUp]=
					|editBox.MovePageUp *
				[forms.Keys.PageDown]=
					|editBox.MovePageDown *
			[forms.Keys.Shift]=
				[forms.Keys.Left]=
					|editBox.SelectCharLeft *
				[forms.Keys.Right]=
					|editBox.SelectCharRight *
			[forms.Keys.Control]=
				[forms.Keys.S]=
					|commands.Save *
				[forms.Keys.I]=
					|editBox.StartInteractiveSearch *
				[forms.Keys.H]=
					|editBox.FindAndReplace *
				[forms.Keys.Left]=
					|editBox.MoveWordLeft *
				[forms.Keys.Right]=
					|editBox.MoveWordRight *
				[forms.Keys.Back]=
					|editBox.DeleteWordLeft *
				[forms.Keys.Delete]=
					|editBox.DeleteWordRight *
				[forms.Keys.Home]=
					|editBox.MoveDocumentStart *
				[forms.Keys.End]=
					|editBox.MoveDocumentEnd *
			[forms.Keys.Alt]=
				[forms.Keys.K]=
					|editBox.MoveLineDown *
				[forms.Keys.L]=
					|editBox.MoveLineUp *
				[forms.Keys.Oemtilde]=
					|editBox.MoveCharRight *
				[forms.Keys.J]=
					|editBox.MoveCharLeft *
				[forms.Keys.U]=
					|editBox.MoveLineStart *
				[forms.Keys.OemSemicolon]=
					|editBox.MoveLineEnd *
				[forms.Keys.N]=
					|editBox.DeleteCharLeft *
				[forms.Keys.M]=
					|editBox.DeleteCharRight *
			[CombinedModifierKeys.ControlShift]=
				[forms.Keys.Left]=
					|editBox.SelectWordLeft *
				[forms.Keys.Right]=
					|editBox.SelectWordRight *
			[CombinedModifierKeys.AltShift]=
				[forms.Keys.J]=
					|editBox.SelectCharLeft *
				[forms.Keys.Oemtilde]=
					|editBox.SelectCharRight *
				[forms.Keys.L]=
					|editBox.SelectLineUp *
				[forms.Keys.K]=
					|editBox.SelectLineDown *
				[forms.Keys.OemSemicolon]=
					|editBox.SelectLineEnd *
				[forms.Keys.U]=
					|editBox.SelectLineStart *
			[CombinedModifierKeys.AltControl]=
				[forms.Keys.J]=
					|editBox.MoveWordLeft *
				[forms.Keys.Oemtilde]=
					|editBox.MoveWordRight *
				[forms.Keys.OemSemicolon]=
					|editBox.MoveDocumentEnd *
				[forms.Keys.U]=
					|editBox.MoveDocumentStart *
				[forms.Keys.N]=
					|editBox.DeleteWordLeft *
				[forms.Keys.M]=
					|editBox.DeleteWordRight *
				[forms.Keys.L]=
					|editBox.MovePageUp *
				[forms.Keys.K]=
					|editBox.MovePageDown *
			[CombinedModifierKeys.AltControlShift]=
				[forms.Keys.J]=
					|editBox.SelectWordLeft *
				[forms.Keys.Oemtilde]=
					|editBox.SelectWordRight *
		editBox=
			editBox=Editor.ScrollingTextBox *
			editBox.ShowSelectionMargin.set
				1
			editBox.AcceptsTab.set
				1
			editBox.Dock.set
				["System.Windows.Forms"].DockStyle.Fill
			editBox.ScrollBars.set
				["System.Windows.Forms"].RichTextBoxScrollBars.ForcedBoth
			editBox.Moved.add
				=
					|
						cases=
							[*]=
								|commands.Reverse *
							=
								|commands.Continue *
						breakpoint=process.BreakPoint.get *
						position=breakpoint
						line=position.Line.get *
						forward=library.math.smaller
							line
							editBox.LineIndex.get *
						cases.[forward] *
			editBox.KeyDown.add
				=
					|
						eventArgs=arg.[2]
						modifier=eventArgs.Modifiers.get *
						key=eventArgs.KeyCode.get *
						shortcuts=shortcutCombinations.[modifier]
						exists=library.map.contains
							map=shortcuts
							key=key
						cases=
							=
								|
									editBox.SuspendWindowUpdate *
									shortcuts.[key] *
									editBox.ResumeWindowUpdate *
									eventArgs.Handled.set
										1
							[*]=
								|*
						cases.[exists] *
			editBox.RealText.set
				Meta.FileAccess.Read
					Meta.LocalStrategy.Path.get *
			current=editBox
		form=
			form=["System.Windows.Forms"].Form *
			form.Text.set
				"Meta Edit"
			form.Font.set
				["System.Drawing"].Font
					"Courier New"
					10
			controls=form.Controls.get *
			controls.AddRange
				=
					editBox
			menu=
				File=
					Save=
						|commands.Save *
					Close=
						|form.Close *
				Debug=
					Start=
						|commands.Start *
					Continue=
						|commands.Continue *
					Reverse=
						|commands.Reverse *
					Stop=
						|commands.Stop *
			form.Menu.set
				["System.Windows.Forms"].MainMenu
					library.map.apply
						array=library.map.keys menu
						with=
							|
								topKey=arg
								current=["System.Windows.Forms"].MenuItem
									topKey
									library.map.apply
										array=library.map.keys menu.[topKey]
										with=
											|["System.Windows.Forms"].MenuItem
												arg
												menu.[topKey].[arg]
			current=form
		form.ShowDialog *
html=
	|
		tags=
			create=
				|
					name=arg
					|library.map.join
						"<"
						name
						">"
						arg.inner
						"</"
						name
						">"
			current=library.map.merge library.map.apply
				with=
					|
						[arg]=create arg
				array=
					"html"
					"head"
					"title"
					"body"
					"h1"
					"h2"
					"h3"
					"h4"
					"h5"
					"h6"
					"p"
					"br"
					"pre"
					"b"
					"i"
					"table"
					"tr"
					"td"
					"form"
					"input"
		table=
			|
				tags=tags *
				current=tags.table library.map.join library.map.apply
					array=arg
					with=
						|tags.tr library.map.join library.map.apply
							array=arg
							with=
								|tags.td arg
		display=
			|
				file.write
					file="C:\test.html"
					text=arg
				process=System.Process *
				startInfo=process.StartInfo.get *
				startInfo.FileName.set
					"iexplore.exe"
				startInfo.Arguments.set
					"C:\test.html"
				process.Start *
market=
	|
		html=html *
		library.map.join
			html.tags.h1
				inner="hello world"
			html.tags.form
				inner=html.tags.input
					inner="hello"