parser|
	rule defaultFunction
		function
			arg|
				parser|
					map arg.condition parser
					: if (succeeded map)
						|merge
							. parser
							. merge
								. map
								. arg.result (merge
									. parser
									. map)
								. 
									parsed arg.parse map.parsed
		argument
			result
				|0
			parse
				|@
			indenting
				|@
	charRule
		compare|rule
			condition
				parser|if (and
					.
						|not (null parser.text)
					. 
						|compare parser.text.[1])
					|
						parsed parser.text.[1]
						text rest parser.text
	character
		char|charRule
			input|equal input char
	characterSet
		chars|charRule
			input|contains
				array chars
				value input
	characterExcept
		chars|charRule
			input|not (contains
				value input
				array chars)
	loopRule
		arg|rule
			condition
				parser|
					implementation
						impArg|if (arg.tooMuch
							count add impArg.n 1
							parser impArg.parser)
							|impArg.parser
							else
								|
									res arg.rule impArg.parser
									: if (succeeded res)
										|
											nextResult implementation
												parser res
												n add impArg.n 1
											: if (succeeded nextResult)
												|
													parsed join
														. 
															. res.parsed
														. nextResult.parsed
													text nextResult.text
													indentationCount if (hasKey nextResult "indentationCount")
														|nextResult.indentationCount
										else
											|if (not (arg.tooFew
												count impArg.n
												parser impArg.parser))
												|impArg.parser
					: implementation
						parser merge
							. parser
							. 
								parsed 0
						n 0
	nTimes
		arg|loopRule
			tooMuch
				upperArg|smaller (arg.n upperArg.parser) upperArg.count
			tooFew
				lowerArg|smaller lowerArg.count (arg.n lowerArg.parser)
			rule arg.rule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|greater 1 arg.count
			rule arg
	sequence
		rules|rule
			condition
				parser|
					implementation
						arg|if (hasKey arg.rules 1)
							|
								ruleResult arg.rules.[1] arg.parser
								: if (succeeded ruleResult)
									|
										nextResult implementation
											parser
												parsed 0
												text ruleResult.text
												indentationCount 0
											rules rest arg.rules
										: if (succeeded nextResult)
											|
												text nextResult.text
												parsed join
													.
														. ruleResult.parsed
													. nextResult.parsed
											else
												|nextResult
							else
								|arg.parser
					: implementation
						parser parser
						rules rules
	succeeded
		arg|hasKey arg "parsed"
	alternatives
		alts|rule
			condition
				parser|
					implementation
						arg|if (not (null arg))
							|
								altResult try
									function
										|arg.[1] parser
									catch
										|
											. print arg
											. console.readLine 0
								: if (succeeded altResult)
									|
										parsed altResult.parsed
										text altResult.text
									else
										|implementation (rest arg)
					: implementation alts
	optional
		subRule|
			parser|merge
				.
					parsed 0
					text parser.text
				. subRule parser
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	number rule
		condition oneOrMore (characterSet "0123456789")
		parse
			|/.Meta.Number.Parse @
	newLine alternatives
		. character 10
		. sequence
			. character 13
			. character 10
	whitespace zeroOrMore (characterSet
		. 9
		. ' ')
	endOfLine sequence
		. whitespace
		. newLine
	indentRule
		change|rule
			condition nTimes
				n
					parser|add parser.indentationCount change
				rule character 9
			result
				parser|
					indentationCount add parser.indentationCount change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	stringLine zeroOrMore (characterExcept
		. 10
		. 13
		. '"')
	prefix
		prefixRule|
			realRule|rule
				condition sequence
					. prefixRule
					. realRule
				parse
					|@.[2]
	suffix
		suffixRule|
			realRule|rule
				condition sequence
					. realRule
					. suffixRule
				parse
					|@.[1]
	characterDataExpression prefix (character 39) (suffix (character 39) (characterExcept
		. 39))
	string suffix (sequence
		. optional newLine
		. optional (character '"')) (prefix (character '"') (alternatives
		. oneOrMore (characterExcept
			. 10
			. 13
			. '"')
		. sequence
			. prefix (sequence
				. newLine
				. indentation) stringLine))
	lookupString oneOrMore lookupForbidden
	value
		parser|
			rule alternatives
				. map
				. string
				. number
				. characterDataExpression
			: rule parser.text
	lookupAnything prefix (character '[') (suffix (sequence
		. zeroOrMore 9
		. character ']') value)
	entry rule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. whitespace
			. value
		parse
			|
				[@.[2]] @.[4]
	onePlusX
		arg|rule
			condition sequence
				. rule
					condition arg.first
					parse
						|
							. @
				. zeroOrMore (rule
					condition prefix arg.delimiter arg.step)
			parse
				|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	expression
		parser|
			localRule rule
				condition alternatives
					. literalExpression
			: localRule
				text parser.text
	function rule
		condition sequence
			. zeroOrMore (characterExcept
				. '"'
				. ' '
				. 10)
			. character '|'
			. expression
		parse
			|
				parameter @.[1]
				expression @.[3]
	lookupAnythingExpression suffix (sequence
		. zeroOrMore (character 9)
		. character ']') (prefix (character '[') expression)
	lookupStringExpression rule
		condition lookupString
		parse
			|
				literal @
	search rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		parse
			|
				search @
	root rule
		condition character '/'
		parse
			|
				root 0
	ruleCurrent rule
		condition character ':'
		parse
			|
				["current"] 0
	realLookup rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		parse
			|
				lookup @
	lookup alternatives
		. ruleCurrent
		. realLookup
	select rule
		condition onePlusX
			first alternatives
				. root
				. search
				. lookup
			delimiter character '.'
			step lookup
		parse
			|
				select @
	functionExpression rule
		condition function
		parse
			|
				key
					.
						lookup
							literal "function"
				value
					literal @
	statement alternatives
		. functionExpression
		. rule
			condition sequence
				. keys
				. whitespace
				. expression
				. endOfLine
			parse
				|
					key @.[1]
					value @.[3]
	program rule
		condition sequence
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequence
				. indentation
				. rule
					condition statement
					parse
						|
							. @
				. zeroOrMore sequence
					. alternatives
						. sameIndentation
						. dedentation
					. statement
			. 
				parser|"p.defaultKeys.Pop 0"
		parse
			arg|
				program arg.[2]
	call rule
		condition sequence
			. select
			. alternatives
				. prefix (sequence
					. alternatives
						. character ' '
						. character 9) expression
				. program
		parse
			|
				call
					callable @.[1]
					argument @.[2]
	emptyMap rule
		condition character '0'
		parse
			|0
	literalExpression rule
		condition alternatives
			. emptyMap
			. string
			. number
			. characterDataExpression
		parse
			arg|
				literal arg
	keysSearch prefix (character '$') search
	autokeyLookup rule
		condition character '.'
		result
			arg|
				defaultKey add arg.defaultKey 1
				parsed
					lookup
						literal arg.defaultKey
	keys onePlusX
		first alternatives
			. keysSearch
			. lookup
			. autokeyLookup
		delimiter character '.'
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer number
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest literalExpression 
				text "
					"hello"
				"
			characterTest literalExpression 
				text "'a'"
			emptyMapTest literalExpression 
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
		searchTest search
			text "hello"
		rootTest root
			text "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest select
				text "hello"
			severalTest select
				text "hello.hello"
			complexTest select
				text"
					hello.["world"]
				"
		keysSearchTest
			simple keysSearch
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0