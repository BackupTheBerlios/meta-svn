parser|
	success
		value|(defaultFunction
			arg|if (@.function value)
				then
					|arg.then value
				else
					|arg.else value)
			else
				|0
			function
				|hasKey @ "parsed"
	baseRule (defaultFunction
		arg|
			parser|success (arg.condition parser)
				then
					|merge (merge parser (merge @ (arg.result (merge parser @))))
						parsed arg.parse @.parsed)
		result
			|0
		parse
			|@
		indenting
			|@
	rule
		condition|
			parse|baseRule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|baseRule
				condition condition
				result result
	matchChar
		compare|
			mod|(rule
				parser|if (and
					.
						|not (null parser.text)
					. 
						|compare
							char parser.text.[1]
							mod mod)
					then
						|
							parsed parser.text.[1]
							text rest parser.text) 0
	character matchChar
		|equal @.mod @.char
	characterSet matchChar
		|contains @.mod @.char
	characterExcept matchChar
		|not (contains @.mod @.char)
	loopRule
		arg|(rule
			parser|
				implementation
					impArg|if (arg.tooMuch
						count add impArg.n 1
						parser impArg.parser)
						then
							|impArg.parser
						else
							|success (arg.rule impArg.parser)
								then
									res|success (implementation
										parser res
										n add impArg.n 1)
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (not (arg.tooFew
										count impArg.n
										parser impArg.parser))
										then
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0
	nTimes
		loopedRule|
			n|loopRule
				tooMuch
					@|smaller (n @.parser) @.count
				tooFew
					@|smaller @.count (n @.parser)
				rule loopedRule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|greater 1 arg.count
			rule arg
	sequence
		mod|
			parser|
				implementation
					arg|if (hasKey arg.rules 1)
						then
							|success (arg.rules.[1] arg.parser)
								then
									result|success (implementation
										parser
											parsed 0
											text result.text
											indentationCount 0
										rules rest arg.rules)
										then
											|
												text @.text
												parsed prepend result.parsed @.parsed
										else
											|@
						else
							|arg.parser
				: implementation
					parser parser
					rules mod
	alternatives
		mod|
			parser|
				implementation
					arg|if (not (equal arg 0))
						then
							|success (arg.[1] parser)
								then
									|@
								else
									|implementation (rest arg)
				: implementation mod
	alternative
		first|
			second|alternatives
				. first
				. second
	optional
		mod|
			parser|merge parser (mod parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	syntax
		charDelimiter character 39
		char characterExcept 39
		linefeed character 10
		carriageReturn character 13
		whitespace characterSet
			. 9
			. ' '
		indentation character 9
		string character '"'
		stringLineText characterExcept
			. 10
			. 13
			. '"'
		lookupStart character '['
		lookupEnd character ']'
		function character '|'
		root character '/'
		current character ':'
		select character '.'
		tab character 9
		space character ' '
		emptyMap character '0'
		search character '$'
	number rule (oneOrMore (characterSet "0123456789"))
		|/.Meta.Number.Parse @
	newLine alternative syntax.linefeed (sequence
		. syntax.carriageReturn
		. syntax.linefeed)
	whitespace zeroOrMore syntax.whitespace
	endOfLine sequence
		. whitespace
		. newLine
	indentRule
		change|generalRule (nTimes syntax.indentation
			|add @.indentationCount change)
			|
				indentationCount add @.indentationCount change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	prefix
		prefixRule|
			realRule|rule (sequence
				. prefixRule
				. realRule)
				|@.[2]
	suffix
		suffixRule|
			realRule|rule (sequence
				. realRule
				. suffixRule)
				|@.[1]
	characterDataExpression prefix syntax.charDelimiter (suffix syntax.charDelimiter syntax.char)
	stringLine zeroOrMore syntax.stringLineText
	string suffix (sequence
		. optional newLine
		. optional syntax.string) (prefix syntax.string (alternative (oneOrMore syntax.stringLineText) (prefix (sequence
		. newLine
		. indentation) stringLine)))
	lookupString oneOrMore lookupForbidden
	delayed
		mod|
			parser|mod 0 parser
	value delayed
		|alternatives
			. number
			. characterDataExpression
			. string
			. map
	lookupAnything prefix syntax.lookupStart (suffix (sequence
		. zeroOrMore 9
		. syntax.lookupEnd) value)
	entry delayed
		|rule (alternative function (rule (alternative (alternative (lookupString lookupAnything)) (alternative (prefix (oneOrMore syntax.whitespace) value) map)))
			|
				[@.[1]] @.[2]) 0
	entry delayed
		|rule (alternative functionRule (rule (sequence
			. alternative lookupString lookupAnything
			. alternative (prefix (oneOrMore syntax.whitespace) value) map)
			|
				[@.[1]] @.[2])) 0
	onePlusX
		arg|(rule (sequence
			. rule arg.first
				|
					. @
			. zeroOrMore (baseRule
				condition prefix arg.delimiter arg.step)))
			|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	expression delayed
		|alternatives
			. literalExpression
			. characterDataExpression
			. emptyMap
			. select
	lookupAnythingExpression suffix (sequence
		. zeroOrMore syntax.indentation
		. syntax.lookupEnd) (prefix syntax.lookupStart expression)
	lookupStringExpression rule lookupString
		|
			literal @
	search (rule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression))
		|
			search @
	root rule syntax.root
		|
			root 0
	ruleCurrent rule syntax.current
		|
			["current"] 0
	realLookup rule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression)
		|
			lookup @
	lookup alternatives
		. ruleCurrent
		. realLookup
	select (rule (onePlusX
		first alternatives
			. root
			. search
			. lookup
		delimiter syntax.select
		step lookup))
		|
			select @
	functionRule rule (sequence
		. zeroOrMore (characterExcept
			. ' '
			. 10
			. '|')
		. syntax.function
		. select)
		|
			parameter @.[1]
			expression @.[3]
	functionExpression rule functionRule
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	normalStatement rule (sequence
		. keys
		. whitespace
		. expression
		. endOfLine)
		|
			key @.[1]
			value @.[3]
	statement alternatives
		. functionExpression
		. normalStatement
	program (rule (sequence
		.
			parser|
				. "p.defaultKeys.Push 1"
				parsed 0
				text parser.text.text
		. sequence
			. indentation
			. onePlusX
				first statement
				step statement
				delimiter sameIndentation
			. dedentation
		. 
			parser|"p.defaultKeys.Pop 0"))
		|
			program @.[2]
	call rule (sequence
		. select
		. alternatives
			. prefix (sequence
				. alternatives
					. syntax.space
					. syntax.tab) expression
			. program)
		|
			call
				callable @.[1]
				argument @.[2]
	emptyMap rule syntax.emptyMap
		|0
	literalExpression (rule (alternatives
		. emptyMap
		. string
		. number
		. characterDataExpression))
		|
			literal @
	keysSearch prefix syntax.search search
	autokeyLookup generalRule syntax.select
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keys onePlusX
		first alternatives
			. keysSearch
			. lookup
			. autokeyLookup
		delimiter syntax.select
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine expression
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer expression
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest expression
				text "
					"hello"
				"
			characterTest expression
				text "'a'"
			emptyMapTest expression
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
			complex lookupAnythingExpression
				text "[[hello]]"
		searchTest search
			text "hello"
		rootTest expression
			text "/"
		ruleCurrentTest 
			shouldMatch expression
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest expression
				text "hello"
			severalTest expression
				text "hello.hello"
			complexTest expression
				text"
					hello.["world"]
				"
		keysSearchTest
			simple expression
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0
		autokeyLookupTest autokeyLookup
			text "."
			defaultKey 1
		functionTest
			simple functionRule
				text "asdf|hello"
		functionTest
			simple functionExpression
				text "asdf|hello"
		valueTest
			stringTest value 
				text "
					"hello"
				"
				indentationCount 0
			numberTest value
				text "0928341"
			characterTest value
				text "'c'"
		entryTest 
			simple entry
				text "
					asdf "hello"
				"
				indentationCount 0
			functionTest entry
				text "asdf|hello"
		mapTest
			simple map
				text "
					asdf "hello"
					qwerty "hi"
				"
				indentationCount 0