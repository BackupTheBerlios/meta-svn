integer "0123456789"
codeKeys
	parameterName "parameterName"
	root "root"
	search "search"
	lookup "lookup"
	current "current"
	scope "scope"
	literal "literal"
	function "function"
	call "call"
	callable "callable"
	argument "argument"
	select "select"
	program "program"
	key "key"
	value "value"
text|
	syntax
		autokey '.'
		callStart '('
		callEnd ')'
		root '/'
		search '$'
		negative '-'
		fraction "/"
		endOfFile 65535
		indentation "\t"
		unixNewLine "\n"
		windowsNewLine "\r\n"
		function '|'
		string '"'
		lookupStart '['
		lookupEnd ']'
		emptyMap '0'
		call ' '
		select '.'
		character "'"
		assignment ' '
		space ' '
		tab "\t"
		mapCurrent "current"
		integer "0123456789"
		lookupStringForbidden
			. call
			. indentation
			. "\r"
			. "\n"
			. assignment
			. select
			. function
			. string
			. lookupStart
			. lookupEnd
			. emptyMap
			. search
			. root
			. callStart
			. callEnd
			. character
	number rule
		condition oneOrMore character syntax.integer
		result
			text|/.Meta.Number.Parse text
	untested "!!!!!!"
	newline alternatives
		. character syntax.unixNewLine
		. stringRule syntax.windowsNewLine
	endOfLine sequence
		. zeroOrMore alternatives
			. character syntax.space
			. character syntax.tab
		. newline
	indentation alternatives
		.
			text|if
				condition startOfFile
				then
					|
						$startOfFile 0
						result 0
						rest text
		. rule
			condition sequence
				. endOfLine
				. 
					text|nTimes
						n add
							. indentationCount
							. 1
						rule character syntax.indentation
			result
				|
					$indentationCount add
						. indentationCount
						. 1
	sameIndentation
		|nTimes
			n indentationCount
			rule character syntax.indentation
	stringLine zeroOrMore characterExcept
		. syntax.unixNewLine
		. syntax.windowsNewLine.[1]
	stringDedentation 
		rule sequence
			. endOfLine
			. |nTimes
				n subtract
					. indentationCount
					. 1
				rule character syntax.indentation
		result
			|
				$indentationCount subtract
					. indentationCount
					. 1
	characterDataExpression prePost
		pre character syntax.character
		rule characterExcept syntax.character
		post character syntax.character
	string prePost
		pre syntax.string
		rule alternatives
			. oneOrMore characterExcept
				. syntax.unixNewLine
				. syntax.windowsNewLine.[1]
				. syntax.string
			. prePost
				pre indentation
				rule sequence
					. stringLine
					. zeroOrMore
						. endOfLine
						. sameIndentation
						. sequence
							. character syntax.unixNewLine
							. stringLine
				post stringDedentation
		post syntax.string
	lookupString oneOrMore characterExcept syntax.lookupStringForbidden
	map prePost
		pre indentation
		rule sequence
			. entry
			. oneOrMore sequence alternatives
				. sequence
					. sameIndentation
					. Entry.Match(parser, out matched)));
		post dedentation
	value alternatives
		. map
		. string,
		. number
		. characterDataExpression
	lookupAnything sequence
		. character syntax.lookupStart
		. value
		. zeroOrMore syntax.indentation
		. character syntax.lookupEnd
	entry sequence
		. function
		. alternatives
			. lookupString
			. lookupAnything
		. character syntax.assignment
		. value.Match
	function sequence
		. CodeKeys.ParameterName
		. zeroOrMore characterExcept
			syntax.string,
			syntax.function,
			syntax.unixNewLine
		. sequence character syntax.function
		. expressionData
	file sequence
		. optional sequence
			. stringRule "#!"
			. zeroOrMore characterExcept syntax.unixNewLine
			. EndOfLine
		. Map
	call 
		. CodeKeys.Call
		. sequence
		. CodeKeys.Callable
		. alternatives
			. Select,
			. ExplicitCall
		. CodeKeys.Argument
		. alternatives
			. sequence(
				. alternatives
					. syntax.call
					. syntax.indentation
				. expression
			. program
	dedentation
		|
			$indentationCount subtract
				indentationCount
				1
	functionExpression = sequence
		. CodeKeys.Key
		.
			.
				[CodeKeys.Lookup]
					[CodeKeys.Literal] CodeKeys.Function
		. CodeKeys.Value
		. CodeKeys.Literal
		. function
	whitespace zeroOrMore alternatives
		. syntax.tab
		. syntax.space
	emptyMap
		rule syntax.emptyMap
		result 0
	literalExpression sequence
		. CodeKeys.Literal),
		. alternatives
			. emptyMap
			. string
			. number
			. characterDataExpression
	lookupAnythingExpression sequence
		. syntax.lookupStart
		. Expression
		. zeroOrMore syntax.indentation
		. syntax.lookupEnd
	lookupStringExpression sequence 
		. CodeKeys.Literal
		. LookupString
	current sequence
		rule syntax.current
		result
			current 0
	root sequence
		rule syntax.root
		result
			[CodeKeys.Root] 0
	lookup alternatives
		. Current
		. sequence
			. CodeKeys.Lookup
			. alternatives
				. lookupStringExpression
				. lookupAnythingExpression
	search sequence
		. CodeKeys.Search
		. alternatives
			. LookupStringExpression
			. LookupAnythingExpression
	select sequence
		. CodeKeys.Select
		. sequence
			. 1
			. alternatives
				root
				search,
				lookup,
			. zeroOrMore
				. syntax.select
				. Lookup
	keysSearch sequence
		. syntax.search
		. search
	AutokeyLookup
		rule syntax.autokey
		result
			[CodeKeys.Lookup]
				[CodeKeys.Literal] last defaultKeys
			$defaultKeys push.Push(p.defaultKeys.Pop() + 1);
			return null;
	keys sequence
		. 1
		. alternatives
			. keysSearch,
			. lookup,
			. autokeyLookup
		. zeroOrMore
			. sequence
				. syntax.select
				. Lookup	
	statement sequence
		. alternatives
			. functionExpression
			. alternatives
				. sequence
					. CodeKeys.Key
					. keys
					. optional syntax.assignment
					. CodeKeys.Value
					. expression
					. endOfLine
	program sequence
		. CodeKeys.Program
		. p.defaultKeys.Push(1);
		. sequence
			. indentation
			. 1
			. statement
			. zeroOrMore sequence
				. alternatives
					. sameIndentation
					. dedentation
				. statement
		. p.defaultKeys.Pop();
	untested "!!!!!!"
	stringCharacter characterExcept
		. syntax.string
	stringTest prePost
		pre character syntax.string
		rule zeroOrMore stringCharacter
		post character syntax.string
	string rule
		condition
			text|
				current if
					condition 1
					then
						|
							result text
							rest slice
								array text
								start add
									. length text
									. 1
		result
			text|text
	string prePost
		pre character
			. syntax.string
		rule zeroOrMore characterExcept
			. syntax.string
		post character
			. syntax.string
	expression sequence
		. number
	numberTest rule
		condition zeroOrMore character syntax.integer
		result
			text|/.Meta.Number.Parse text
	parsed string "
		"12344321 asdfasdf"
	"
	. print parsed
	current parsed
character
	documentation "Matches one character."
	chars|rule
		condition
			text|if
				condition not zero text
				then
					|if
						condition contains
							value first text
							array chars
						then
							|
								result first text
								rest slice
									array text
									start 2
						else
							|
								. print chars
								current 0
		result
			char|char
characterExcept
	documentation "Matches one character that is not the provided character."
	chars|rule
		condition
			text|if
				condition not zero text
				then
					|if
						condition not contains
							value first text
							array chars
						then
							|
								result first text
								rest slice
									array text
									start 2
		result
			char|char
stringRule
	documentation "Matches the provided sequence of characters."
	string|sequence apply
		array string
		function
			char|character char
oneOrMore
	documentation "Matches one or more times."
	status "untested"
	rule|
		text|
			loop zeroOrMore rule
			loopResult loop text
			current if
				condition not zero loopResult
				then
					|if
						condition not zero loopResult.result
						then
							|loopResult
zeroOrMore
	documentation "Matches zero or more times."
	rule|
		text|
			rest text
			result while
				condition
					|not zero rule rest
				function
					|
						ruleResult rule rest
						$rest ruleResult.rest
						current ruleResult.result
sequence
	documentation "Matches a sequence of rules."
	rules|
		text|
			matched 0
			rest text
			applied apply
				array rules
				function
					rule|
						ruleResult rule rest
						. if
							condition hasKey
								map ruleResult
								key "result"
							then
								|
									$rest ruleResult.rest
									$matched join
										. matched
										.
											. ruleResult.result
			result if
				condition equal
					. length applied
					. length rules
				then
					|
						result matched

prePost
	documentation "Matches a rule and throws away the results of a preceding and a following rule."
	arg|
		text|
			preResult arg.pre text
			current if
				condition not zero preResult
				then
					|
						ruleResult arg.rule preResult.rest
						current if
							condition not zero ruleResult
							then
								|
									postResult arg.post ruleResult.rest
									current if
										condition not zero postResult
										then
											|
												result ruleResult.result
												rest postResult.rest
alternatives
	documentation "Matches one of several alternative rules."
	alts|
		text|
			result 0
			. apply
				array alts
				condition
					alt|
						applied alt text
						current if
							condition not zero applied
							then
								|
									$result applied.result
									current 0
							else
								|1
				function
					|0
rule
	documentation "A rule returns the result in 'result' or an empty map, if the rule did not match."
	arg|
		text|
			map arg.condition text
			stuff if
				condition hasKey
					map map
					key "result"
				then
					|
						result arg.result map.result
						rest map.rest
			current stuff