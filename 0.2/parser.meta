parser|
	rule defaultFunction
		function
			arg|
				parser|
					map arg.condition parser
					: if
						condition succeeded map
						then
							|merge
								. parser
								. merge
									. map
									. arg.result (merge
										. parser
										. map)
									. 
										parsed arg.parse map.parsed
		argument
			result
				|0
			parse
				|@
			indenting
				|@
	charRule
		compare|rule
			condition
				parser|if
					condition and
						.
							|not (null parser.text)
						. 
							|compare parser.text.[1]
					then
						|
							parsed parser.text.[1]
							text rest parser.text
	character
		char|charRule
			input|equal
				. input
				. char
	characterSet
		chars|charRule
			input|contains
				array chars
				value input
	characterExcept
		chars|charRule
			input|not (contains
				value input
				array chars)
	stringRule
		string|sequence (apply
			array string
			function
				char|character char)
	loopRule
		arg|rule
			condition
				parser|
					implementation
						impArg|if
							condition arg.tooMuch
								count add
									. impArg.n
									. 1
								parser impArg.parser
							then
								|impArg.parser
							else
								|
									res arg.rule impArg.parser
									: if
										condition succeeded res
										then
											|
												nextResult implementation
													parser res
													n add
														. impArg.n
														. 1
												: if
													condition succeeded nextResult
													then
														|
															parsed join
																. 
																	. res.parsed
																. nextResult.parsed
															text nextResult.text
															indentationCount if
																condition hasKey
																	map nextResult
																	key "indentationCount"
																then
																	|nextResult.indentationCount
										else
											|if
												condition not (arg.tooFew
													count impArg.n
													parser impArg.parser)
												then
													|impArg.parser
					: implementation
						parser merge
							. parser
							. 
								parsed 0
						n 0
	nTimes
		arg|loopRule
			tooMuch
				upperArg|strictlyIncreasing
					. arg.n upperArg.parser
					. upperArg.count
			tooFew
				lowerArg|strictlyIncreasing
					. lowerArg.count
					. arg.n lowerArg.parser
			rule arg.rule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|strictlyDecreasing
					. 1
					. arg.count
			rule arg
	sequence
		rules|rule
			condition
				parser|
					implementation
						arg|if
							condition hasKey
								map arg.rules
								key 1
							then
								|
									ruleResult arg.rules.[1] arg.parser
									: if
										condition succeeded ruleResult
										then
											|
												nextResult implementation
													parser
														parsed 0
														text ruleResult.text
														indentationCount 0
													rules rest arg.rules
												: if
													condition succeeded nextResult
													then
														|
															text nextResult.text
															parsed join
																.
																	. ruleResult.parsed
																. nextResult.parsed
													else
														|nextResult
							else
								|arg.parser
					: implementation
						parser parser
						rules rules
	prePost
		arg|rule
			condition sequence (join
				. 
					. arg.pre
					. arg.rule
				. if
					condition hasKey
						map arg
						key "post"
					then
						|
							. arg.post)
			parse
				|@.[2]
	succeeded
		arg|hasKey
			map arg
			key "parsed"
	alternatives
		alts|rule
			condition
				parser|
					implementation
						arg|if
							condition not (null arg)
							then
								|
									altResult try
										function
											|arg.[1] parser
										catch
											|
												. print arg
												. console.readLine 0
									: if
										condition succeeded altResult
										then
											|
												parsed altResult.parsed
												text altResult.text
										else
											|implementation (rest arg)
					: implementation alts
	optional
		subRule|
			parser|merge
				.
					parsed 0
					text parser.text
				. subRule parser
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	number rule
		condition oneOrMore (characterSet "0123456789")
		parse
			|/.Meta.Number.Parse @
	newLine alternatives
		. character 10
		. sequence
			. character 13
			. character 10
	whitespace zeroOrMore (characterSet
		. 9
		. ' ')
	endOfLine sequence
		. whitespace
		. newLine
	indentRule
		change|rule
			condition nTimes
				n
					parser|add
						. parser.indentationCount
						. change
				rule character 9
			result
				parser|
					indentationCount add
						. parser.indentationCount
						. change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	stringLine zeroOrMore (characterExcept
		. 10
		. 13
		. '"')
	characterDataExpression prePost
		pre character 39
		rule characterExcept
			. 39
		post character 39
	string prePost
		pre character '"'
		rule alternatives
			. oneOrMore (characterExcept
				. 10
				. 13
				. '"')
			. rule
				condition sequence
					. rule
						condition sequence
							. newLine
							. indentation
							. stringLine
						parse
							|@.[3]
		post sequence
			. optional newLine
			. optional (character '"')
	lookupString oneOrMore lookupForbidden
	value
		parser|
			rule alternatives
				. map
				. string
				. number
				. characterDataExpression
			: rule parser.text
	lookupAnything prePost
		pre character '['
		rule value
		post sequence
			. zeroOrMore 9
			. character ']'
	entry rule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. whitespace
			. value
		parse
			|
				[@.[2]] @.[4]
	onePlusX
		arg|rule
			condition sequence
				. rule
					condition arg.first
					parse
						|
							. @
				. zeroOrMore (rule
					condition prePost
						pre arg.delimiter
						rule arg.step)
			parse
				|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map prePost
		pre indentation
		rule mapCore
		post dedentation
	file mapCore
	expression
		parser|
			localRule rule
				condition alternatives
					. literalExpression
			: localRule
				text parser.text
	function rule
		condition sequence
			. zeroOrMore (characterExcept
				. '"'
				. ' '
				. 10)
			. character '|'
			. expression
		parse
			|
				parameter @.[1]
				expression @.[3]
	lookupAnythingExpression prePost
		pre character '['
		rule expression
		post sequence
			. zeroOrMore (character 9)
			. character ']'
	lookupStringExpression rule
		condition lookupString
		parse
			|
				literal @
	search rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		parse
			|
				search @
	root rule
		condition character '/'
		parse
			|
				root 0
	ruleCurrent rule
		condition character ':'
		parse
			|
				["current"] 0
	realLookup rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		parse
			|
				lookup @
	lookup alternatives
		. ruleCurrent
		. realLookup
	select rule
		condition onePlusX
			first alternatives
				. root
				. search
				. lookup
			delimiter character '.'
			step lookup
		parse
			|
				select @
	functionExpression rule
		condition function
		parse
			|
				key
					.
						lookup
							literal "function"
				value
					literal @
	statement alternatives
		. functionExpression
		. rule
			condition sequence
				. keys
				. whitespace
				. expression
				. endOfLine
			parse
				|
					key @.[1]
					value @.[3]
	program rule
		condition sequence
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequence
				. indentation
				. rule
					condition statement
					parse
						|
							. @
				. zeroOrMore sequence
					. alternatives
						. sameIndentation
						. dedentation
					. statement
			. 
				parser|"p.defaultKeys.Pop 0"
		parse
			arg|
				program arg.[2]
	call rule
		condition sequence
			. select
			. alternatives
				. prePost
					pre sequence
						. alternatives
							. character ' '
							. character 9
					rule expression
				. program
		parse
			|
				call
					callable @.[1]
					argument @.[2]
	emptyMap rule
		condition character '0'
		parse
			|0
	literalExpression rule
		condition alternatives
			. emptyMap
			. string
			. number
			. characterDataExpression
		parse
			arg|
				literal arg
	keysSearch prePost
		pre character '$'
		rule search
	autokeyLookup rule
		condition character '.'
		result
			arg|
				defaultKey add
					. arg.defaultKey
					. 1
				parsed
					lookup
						literal arg.defaultKey
	keys onePlusX
		first alternatives
			. keysSearch
			. lookup
			. autokeyLookup
		delimiter character '.'
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer number
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest literalExpression 
				text "
					"hello"
				"
			characterTest literalExpression 
				text "'a'"
			emptyMapTest literalExpression 
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
		searchTest search
			text "hello"
		rootTest root
			text "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest select
				text "hello"
			severalTest select
				text "hello.hello"
			complexTest select
				text"
					hello.["world"]
				"
		keysSearchTest
			simple keysSearch
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0