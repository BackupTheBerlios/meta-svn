parser|
	conditional
		value|defaultFunction
			function
				arg|if (@.function value)
					then
						|arg.then value
					else
						|arg.else value
			argument
				else
					|0
				function
					|hasKey @ "parsed"
	baseRule defaultFunction
		function
			arg|
				parser|conditional (arg.condition parser)
					then
						|merge (merge parser (merge @ (arg.result (merge parser @))))
							parsed arg.parse @.parsed
		argument
			result
				|0
			parse
				|@
			indenting
				|@
	metaRule
		imp|
			mod|baseRule
				condition
					parser|imp
						mod mod
						parser parser
	rule
		condition|
			parse|baseRule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|baseRule
				condition condition
				result result
	matchChar
		compare|
			mod|(rule
				parser|if (and
					.
						|not (null parser.text)
					. 
						|compare
							char parser.text.[1]
							mod mod)
					then
						|
							parsed parser.text.[1]
							text rest parser.text) 0
	character matchChar
		|equal @.mod @.char
	characterSet matchChar
		|contains @.mod @.char
	characterExcept matchChar
		|not (contains @.mod @.char)
	loopRule
		arg|(rule
			parser|
				implementation
					impArg|if (arg.tooMuch
						count add impArg.n 1
						parser impArg.parser)
						then
							|impArg.parser
						else
							|conditional (arg.rule impArg.parser)
								then
									res|conditional (implementation
										parser res
										n add impArg.n 1)
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (not (arg.tooFew
										count impArg.n
										parser impArg.parser))
										then
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0
	nTimes
		loopedRule|
			n|loopRule
				tooMuch
					@|smaller (n @.parser) @.count
				tooFew
					@|smaller @.count (n @.parser)
				rule loopedRule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|greater 1 arg.count
			rule arg
	sequence metaRule
		meta|
			implementation
				arg|if (hasKey arg.rules 1)
					then
						|conditional (arg.rules.[1] arg.parser)
							then
								result|conditional (implementation
									parser
										parsed 0
										text result.text
										indentationCount 0
									rules rest arg.rules)
									then
										|
											text @.text
											parsed prepend result.parsed @.parsed
									else
										|@
					else
						|arg.parser
			: implementation
				parser meta.parser
				rules meta.mod
	alternatives metaRule
		meta|
			implementation
				arg|if (not (equal arg 0))
					then
						|conditional (arg.[1] meta.parser)
							then
								|@
							else
								|implementation (rest arg)
			: implementation meta.mod
	optional metaRule
		|merge @.parser (@.mod @.parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	syntax
		charDelimiter character 39
		char characterExcept 39
		linefeed character 10
		carriageReturn character 13
		whitespace characterSet
			. 9
			. ' '
		indentation character 9
		string character '"'
		stringLineText characterExcept
			. 10
			. 13
			. '"'
		lookupStart character '['
		lookupEnd character ']'
		function character '|'
		root character '/'
		current character ':'
		select character '.'
		tab character 9
		space character ' '
		emptyMap character '0'
		search character '$'
	number rule (oneOrMore (characterSet "0123456789"))
		|/.Meta.Number.Parse @
	newLine alternatives
		. syntax.linefeed
		. sequence
			. syntax.carriageReturn
			. syntax.linefeed
	whitespace zeroOrMore syntax.whitespace
	endOfLine sequence
		. whitespace
		. newLine
	indentRule
		change|generalRule (nTimes syntax.indentation
			|add @.indentationCount change)
			|
				indentationCount add @.indentationCount change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	prefix
		prefixRule|
			realRule|rule (sequence
				. prefixRule
				. realRule)
				|@.[2]
	suffix
		suffixRule|
			realRule|rule (sequence
				. realRule
				. suffixRule)
				|@.[1]
	characterDataExpression prefix syntax.charDelimiter (suffix syntax.charDelimiter syntax.char)
	stringLine zeroOrMore syntax.stringLineText
	string suffix (sequence
		. optional newLine
		. optional syntax.string) (prefix syntax.string (alternatives
		. oneOrMore syntax.stringLineText
		. sequence
			. prefix (sequence
				. newLine
				. indentation) stringLine))
	lookupString oneOrMore lookupForbidden
	delayed metaRule
		meta|meta.mod 0 meta.parser
	value delayed
		|alternatives
			. map
			. string
			. number
			. characterDataExpression
	lookupAnything prefix syntax.lookupStart (suffix (sequence
		. zeroOrMore 9
		. syntax.lookupEnd) value)
	entry (rule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. whitespace
			. value)
		|
			[@.[2]] @.[4]
	onePlusX
		arg|(rule (sequence
			. rule arg.first
				|
					. @
			. zeroOrMore (baseRule
				condition prefix arg.delimiter arg.step)))
			|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	expression delayed
		|alternatives
			. literalExpression
	function rule (sequence
		. zeroOrMore (characterExcept
			. ' '
			. 10)
		. syntax.function
		. expression)
		|
			parameter @.[1]
			expression @.[3]
	lookupAnythingExpression suffix (sequence
		. zeroOrMore syntax.indentation
		. syntax.lookupEnd) (prefix syntax.lookupStart expression)
	lookupStringExpression rule lookupString
		|
			literal @
	search (rule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression))
		|
			search @
	root rule syntax.root
		|
			root 0
	ruleCurrent rule syntax.current
		|
			["current"] 0
	realLookup rule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression)
		|
			lookup @
	lookup alternatives
		. ruleCurrent
		. realLookup
	select (rule (onePlusX
		first alternatives
			. root
			. search
			. lookup
		delimiter syntax.select
		step lookup))
		|
			select @
	functionExpression rule function
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	normalStatement rule (sequence
		. keys
		. whitespace
		. expression
		. endOfLine)
		|
			key @.[1]
			value @.[3]
	statement alternatives
		. functionExpression
		. normalStatement
	program (rule (sequence
		.
			parser|
				. "p.defaultKeys.Push 1"
				parsed 0
				text parser.text.text
		. sequence
			. indentation
			. onePlusX
				first statement
				step statement
				delimiter sameIndentation
			. dedentation
		. 
			parser|"p.defaultKeys.Pop 0"))
		|
			program @.[2]
	call rule (sequence
		. select
		. alternatives
			. prefix (sequence
				. alternatives
					. syntax.space
					. syntax.tab) expression
			. program)
		|
			call
				callable @.[1]
				argument @.[2]
	emptyMap rule syntax.emptyMap
		|0
	literalExpression (rule (alternatives
		. emptyMap
		. string
		. number
		. characterDataExpression))
		|
			literal @
	keysSearch prefix syntax.search search
	autokeyLookup generalRule syntax.select
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keys onePlusX
		first alternatives
			. keysSearch
			. lookup
			. autokeyLookup
		delimiter syntax.select
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer number
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest literalExpression 
				text "
					"hello"
				"
			characterTest literalExpression 
				text "'a'"
			emptyMapTest literalExpression 
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
		searchTest search
			text "hello"
		rootTest root
			text "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest select
				text "hello"
			severalTest select
				text "hello.hello"
			complexTest select
				text"
					hello.["world"]
				"
		keysSearchTest
			simple keysSearch
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0
