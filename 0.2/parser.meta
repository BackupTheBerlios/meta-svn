parser|
	success
		value|(defaultFunction
			arg|if (@.function value)
				then
					|arg.then value
				else
					|arg.else value)
			then
				|@
			else
				|0
			function
				|hasKey @ "parsed"
	baseRule (defaultFunction
		arg|
			parser|success (arg.condition parser)
				then
					|merge (merge parser (merge @ (arg.result (merge parser @))))
						parsed arg.parse @.parsed)
		result
			|0
		parse
			|@
		indenting
			|@
	rule
		condition|
			parse|baseRule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|baseRule
				condition condition
				result result
	charRule
		compare|
			mod|(rule
				parser|if (and
					.
						|not (equal 0 parser.text)
					. 
						|compare parser.text.[1] mod)
					then
						|
							parsed parser.text.[1]
							text rest parser.text) 0
	character charRule
		char|
			mod|equal mod char
	characterSet charRule
		char|
			mod|contains mod char
	characterExcept charRule
		char|
			mod|not (contains mod char)
	loopRule (defaultFunction
		arg|(rule
			parser|
				implementation
					impArg|if (arg.tooMuch impArg.parser (add impArg.n 1))
						then
							|impArg.parser
						else
							|success (arg.rule impArg.parser)
								then
									res|success (implementation
										parser res
										n add impArg.n 1)
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (arg.tooFew impArg.parser impArg.n)
										else
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0)
		tooMuch
			|
				|0
		tooFew
			|
				|0
	nTimes
		loopedRule|
			n|loopRule
				tooMuch
					parser|
						count|smaller (n parser) count
				tooFew
					parser|
						count|smaller count (n parser)
				rule loopedRule
	zeroOrMore
		looped|loopRule
			rule looped
	oneOrMore
		arg|loopRule
			tooFew
				parser|
					count|greater 1 count
			rule arg
	sequence
		first|
			second|
				parser|success (first parser)
					then
						a|success (second a)
							then
								b|merge parser (merge b
									parsed
										. a.parsed
										. b.parsed)
	alternative
		first|
			second|
				parser|success (first parser)
					else
						|success (second parser) 0
	optional
		mod|
			parser|merge parser (mod parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	set
		whitespace characterSet
			. 9
			. ' '
		stringLineText characterExcept
			. 10
			. 13
			. '"'
		longStringLineText characterExcept
			. 10
			. 13
		char characterExcept
			. 39
	syntax (foreach
		charDelimiter 39
		linefeed 10
		carriageReturn 13
		indentation 9
		string '"'
		lookupStart '['
		lookupEnd ']'
		function '|'
		root '/'
		current ':'
		select '.'
		tab 9
		space ' '
		emptyMap '0'
		search '$'
		callStart '('
		callEnd ')')
		|
			value|character value
	onePlusX
		first|
			step|
				delimiter|(rule (sequence (rule first
					|
						. @) (zeroOrMore (baseRule
					condition prefix delimiter step))))
					|sum @ join
	number rule (oneOrMore (characterSet "0123456789"))
		|/.Meta.StrategyMap.[/.Meta.Number] (/.Meta.Number.Parse.[/.mscorlib.String] @)
	newLine alternative syntax.linefeed (sequence syntax.carriageReturn syntax.linefeed)
	whitespace zeroOrMore set.whitespace
	endOfLine sequence whitespace newLine
	indentRule
		change|generalRule (nTimes syntax.indentation
			|add @.indentationCount change)
			|
				indentationCount add @.indentationCount change
	indentation sequence endOfLine (indentRule 1)
	sameIndentation sequence endOfLine (indentRule 0)
	dedentation indentRule -1
	enclose
		pre|
			post|
				subRule|suffix post (prefix pre subRule)
	prefix
		prefixRule|
			realRule|rule (sequence prefixRule realRule)
				|@.[2]
	suffix
		suffixRule|
			realRule|rule (sequence realRule suffixRule)
				|@.[1]
	nothing
		|0
	characterDataExpression enclose syntax.charDelimiter syntax.charDelimiter set.char
	stringLine zeroOrMore set.stringLineText
	longStringLine zeroOrMore set.longStringLineText
	longString rule (onePlusX longStringLine longStringLine sameIndentation)
		|sum @
			first|
				second|join first ((join 
					. 10) second)
	string enclose syntax.string (optional syntax.string) (alternative (oneOrMore set.stringLineText) longString)
	lookupString oneOrMore lookupForbidden
	delayed
		mod|
			parser|mod 0 parser
	value delayed
		|alternative number (alternative characterDataExpression (alternative string map))
	lookupAnything enclose syntax.lookupStart (sequence (zeroOrMore 9) syntax.lookupEnd) value
	entry delayed
		|rule (alternative functionRule (rule (sequence (alternative lookupString lookupAnything) (alternative (prefix (oneOrMore set.whitespace) value) map))
			|
				[@.[1]] @.[2])) 0
	mapCore rule (onePlusX entry entry sameIndentation)
		|sum @ merge
	map enclose indentation dedentation mapCore
	file mapCore
	alternatives
		alts|sum alts alternative
	expression delayed
		|alternatives
			. literalExpression
			. characterDataExpression
			. emptyMap
			. select
	lookupAnythingExpression enclose syntax.lookupStart (sequence (zeroOrMore syntax.indentation) syntax.lookupEnd) expression
	lookupStringExpression rule lookupString
		|
			literal @
	search rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			search @
	root rule syntax.root
		|
			root 0
	ruleCurrent rule syntax.current
		|
			current 0
	realLookup rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			lookup @
	lookup alternative ruleCurrent realLookup
	select (rule (onePlusX (alternatives
		. root 
		. search
		. lookup) lookup syntax.select))
		|
			select @
	functionRule rule (sequence (zeroOrMore (characterExcept
		. ' '
		. 10
		. '|')) (sequence syntax.function select))
		|
			parameter @.[1]
			expression @.[2].[2]
	functionExpression rule functionRule
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	keysSearch prefix syntax.search search
	autokeyLookup generalRule syntax.select
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keysRule onePlusX (alternatives 
		. keysSearch 
		. lookup
		. autokeyLookup) lookup syntax.select
	normalStatement rule (sequence keysRule (sequence whitespace expression))
		|
			key @.[1]
			value @.[2].[2]
	statement alternative functionExpression normalStatement
	program "
		(rule (sequences
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequences
				. indentation
				. onePlusX
					first statement
					step statement
					delimiter sameIndentation
				. dedentation
			. 
				parser|"p.defaultKeys.Pop 0"))
			|
				program @.[2]
	"
	program rule (enclose indentation dedentation (onePlusX statement statement sameIndentation))
		|
			program @
	call rule (sequence select (alternative (prefix (oneOrMore (alternative syntax.space syntax.tab)) expression) program))
		|
			call @
	explicitCall enclose syntax.callStart syntax.callEnd call
	emptyMap rule syntax.emptyMap
		|0
	literalExpression rule (alternatives
		. emptyMap
		. string
		. number
		. characterDataExpression)
		|
			literal @
	: /.Meta.Serialize.ValueFunction.[/.Meta.Map]
		stringTest
			singleLine expression
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer expression
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest expression
				text "
					"hello"
				"
			characterTest expression
				text "'a'"
			emptyMapTest expression
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
			complex lookupAnythingExpression
				text "[[hello]]"
		searchTest search
			text "hello"
		rootTest expression
			text "/"
		ruleCurrentTest 
			shouldMatch expression
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest expression
				text "hello"
			severalTest expression
				text "hello.hello"
			complexTest expression
				text"
					hello.["world"]
				"
		keysSearchTest
			simple expression
				text "$hello"
		keysTest
			simple keysRule
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
			explicitCall explicitCall
				text "
					(hello "hi")
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "
					
						
				"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "
						
									
					"
					indentationCount 2
				one sameIndentation
					text "
						
								
					"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0
		autokeyLookupTest autokeyLookup
			text "."
			defaultKey 1
		functionTest
			simple functionRule
				text "asdf|hello"
		functionTest
			simple functionExpression
				text "asdf|hello"
		valueTest
			stringTest value 
				text "
					"hello"
				"
				indentationCount 0
			numberTest value
				text "0928341"
			characterTest value
				text "'c'"
		entryTest 
			simple entry
				text "
					asdf "hello"
				"
				indentationCount 0
			functionTest entry
				text "asdf|hello"
		mapTest
			simple map
				text "
					
						asdf "hello"
						qwerty "hi"
						hi "hello"
				"
				indentationCount 0
		statementTest
			simple statement
				text "
					asdf "hello"
				"
				indentationCount 0
		programTest
			simple program
				text "
					
						asdf "hello"
						qwerty "hi"
						hi "hello"
				"
				indentationCount 0
		basicTest "
			file
				text "
					license "
						Copyright (c) 2005, 2006 Christian Staudenmeyer
						
						Permission is hereby granted, free of charge, to any person obtaining
						a copy of this software and associated documentation files (the
						"Software"), to deal in the Software without restriction, including
						without limitation the rights to use, copy, modify, merge, publish,
						distribute, sublicense, and/or sell copies of the Software, and to
						permit persons to whom the Software is furnished to do so, subject to
						the following conditions:
						
						The above copyright notice and this permission notice shall be
						included in all copies or substantial portions of the Software.
						
						THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
						EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
						MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
						NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
						BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
						ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
						CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
						SOFTWARE.
					"
					commandLine|
						asdf "hello"
						shortFunction
							arg|asdf
						shortFunctionTest shortFunction "hello"
						counter 0
				"
				indentationCount 0
		"