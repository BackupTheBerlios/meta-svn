integer "0123456789"
codeKeys
	parameterName "parameterName"
	root "root"
	search "search"
	lookup "lookup"
	current "current"
	scope "scope"
	literal "literal"
	function "function"
	call "call"
	callable "callable"
	argument "argument"
	select "select"
	program "program"
	key "key"
	value "value"
	expression "expression"
parser|
	syntax
		autokey '.'
		callStart '('
		callEnd ')'
		root '/'
		search '$'
		negative '-'
		fraction '/'
		endOfFile 65535
		indentation 9
		unixNewLine 10
		function '|'
		string '"'
		lookupStart '['
		lookupEnd ']'
		emptyMap '0'
		call ' '
		select '.'
		character 39
		assignment ' '
		space ' '
		tab 9
		mapCurrent "current"
		integer "0123456789"
		windowsNewLine
			. 13
			. 10
		lookupStringForbidden
			. call
			. indentation
			. 13
			. 10
			. assignment
			. select
			. function
			. string
			. lookupStart
			. lookupEnd
			. emptyMap
			. search
			. root
			. callStart
			. callEnd
			. character
	character
		documentation "Matches one character."
		char|rule
			condition
				parser|if
					condition and
						.
							|not zero parser.text
						.
							|equal
								. first parser.text
								. char
					then
						|
							parsed first parser.text
							text slice
								array parser.text
								start 2
	characterSet
		documentation "Matches one character in a set."
		chars|rule
			condition
				parser|if
					condition and
						. 
							|not zero parser.text
						.
							|contains
								array chars
								value first parser.text
					then
						|
							parsed first parser.text
							text slice
								array parser.text
								start 2
	characterExcept
		documentation "Matches one character that is not the provided character."
		chars|rule
			condition
				parser|if
					condition and
						. 
							|not zero parser.text
						.
							|not contains
								value first parser.text
								array chars
					then
						|
							parsed first parser.text
							text slice
								array parser.text
								start 2
	stringRule
		documentation "Matches the provided sequence of characters."
		string|sequence apply
			array string
			function
				char|character char
	oneOrMore
		arg|rule
			condition
				parser|
					loop zeroOrMore arg
					loopResult loop
						text parser.text
					current if
						condition and
							.
								|succeeded loopResult
							.
								|not zero loopResult.parsed
						then
							|loopResult
	zeroOrMore
		arg|rule
			condition
				parser|
					text parser.text
					parsed while
						condition
							|succeeded arg
								text text
						function
							|
								argResult arg
									text text
								$text argResult.text
								current argResult.parsed
	sequence
		rules|rule
			condition
				parser|
					implementation
						arg|if
							condition hasKey
								map arg.rules
								key 1
							then
								|
									ruleResult arg.rules.[1] arg.parser
									current if
										condition succeeded ruleResult
										then
											|
												nextResult implementation
													parser ruleResult
													rules rest arg.rules
												current if
													condition succeeded nextResult
													then
														|
															text nextResult.text
															parsed join
																.
																	. ruleResult.parsed
																. nextResult.parsed
													else
														|nextResult
							else
								|arg.parser
					current implementation
						parser parser
						rules rules
	prePost
		documentation "Matches a rule and throws away the results of a preceding and a following rule."
		arg|rule
			condition
				parser|
					preResult arg.pre
						text parser.text
					current if
						condition succeeded preResult
						then
							|
								ruleResult arg.rule
									text preResult.text
								current if
									condition succeeded ruleResult
									then
										|
											postResult arg.post
												text ruleResult.text
											current if
												condition succeeded postResult
												then
													|
														parsed ruleResult.parsed
														text postResult.text
	succeeded
		arg|hasKey
			map arg
			key "parsed"
	alternatives
		alts|rule
			condition
				parser|
					implementation
						arg|if
							condition hasKey
								map arg
								key 1
							then
								|
									altResult arg.[1] parser
									current if
										condition succeeded altResult
										then
											|
												parsed altResult.parsed
												text altResult.text
										else
											|implementation rest arg
					current implementation alts
	nTimes
		arg|rule
			condition
				parser|
					implementation
						impArg|if
							condition equal
								. impArg.n
								. 0
							then
								|impArg.parser
							else
								|
									res arg.rule impArg.parser
									current if
										condition succeeded res
										then
											|
												nextResult implementation
													parser res
													n subtract
														. impArg.n
														. 1
												current if
													condition succeeded nextResult
													then
														|
															parsed join
																. 
																	. res.parsed
																. nextResult.parsed
															text nextResult.text
															indentationCount nextResult.indentationCount
					current implementation
						parser parser
						n arg.n
	rule
		arg|
			parser|
				map arg.condition parser
				stuff if
					condition succeeded map
					then
						|
							$map if
								condition hasKey
									map arg
									key "result"
								then
									|merge
										. map
										. arg.result merge
											. parser
											. map
								else
									|map
							current merge
								. parser
								. map
				current stuff
	optional
		subRule|
			parser|
				subRuleResult subRule parser
				current if
					condition succeeded subRuleResult
					then
						|subRuleResult
					else
						|
							parsed 0
	number rule
		condition oneOrMore characterSet syntax.integer
		result
			parser|
				parsed /.Meta.Number.Parse parser.parsed
	newline alternatives
		. character syntax.unixNewLine
		. stringRule syntax.windowsNewLine
	endOfLine sequence
		. zeroOrMore characterSet
			. character syntax.space
			. character syntax.tab
		. newline
	startOfFile 1
	indentationCount 0
	indentation rule
		condition
			parser|
				localRule nTimes
					n add
						. parser.indentationCount
						. 1
					rule character syntax.indentation
				ruleResult localRule parser
				current ruleResult
		result
			arg|
				indentationCount add
					. arg.indentationCount
					. 1
	sameIndentation rule
		condition
			parser|
				localRule nTimes
					n parser.indentationCount
					rule character syntax.indentation
				ruleResult localRule parser
				current ruleResult
	dedentation rule
		condition
			|
				parsed 0
		result
			arg|
				indentationCount subtract
					. arg.indentationCount
					. 1
	stringLine zeroOrMore characterExcept
		. syntax.unixNewLine
		. syntax.windowsNewLine.[1]
	stringDedentation 
		rule sequence
			. endOfLine
			. |nTimes
				n subtract
					. indentationCount
					. 1
				rule character syntax.indentation
		result
			arg|
				indentationCount subtract
					. arg.indentationCount
					. 1
	characterDataExpression prePost
		pre character syntax.character
		rule characterExcept
			. syntax.character
		post character syntax.character
	string prePost
		pre character syntax.string
		rule alternatives
			. oneOrMore characterExcept
				. syntax.unixNewLine
				. syntax.windowsNewLine.[1]
				. syntax.string
			. prePost
				pre indentation
				rule rule
					condition sequence
						. rule
							condition stringLine
							result
								arg|
									parsed
										. arg.parsed
						. zeroOrMore rule
							condition sequence
								. endOfLine
								. sameIndentation
								. rule
									condition sequence
										. character syntax.unixNewLine
										. stringLine
									result
										arg|
											parsed arg.parsed.[2]
							result
								arg|
									parsed arg.parsed.[3]
					result
						arg|
							parsed join arg.parsed
				post stringDedentation
		post character syntax.string
	lookupString oneOrMore characterExcept syntax.lookupStringForbidden
	value
		parser|
			rule alternatives
				. map
				. string
				. number
				. characterDataExpression
			current rule parser.text
	lookupAnything rule
		condition sequence
			. character syntax.lookupStart
			. value
			. zeroOrMore syntax.indentation
			. character syntax.lookupEnd
		result
			arg|
				parsed arg.parsed.[2]
	entry rule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. optional character syntax.assignment
			. value
		result
			arg|
				parsed
					[arg.parsed.[2]] arg.parsed.[4]
	mapCore sequence
		. rule
			condition entry
			result
				arg|
					parsed
						. arg.parsed
		. oneOrMore rule
			condition sequence
				. sameIndentation
				. entry
			result
				arg|
					parsed arg.parsed.[2]
	map prePost
		pre indentation
		rule mapCore
		post dedentation
	file mapCore
	expression
		parser|
			localRule rule
				condition alternatives
					. literalExpression
			current localRule
				text parser.text
	function rule
		condition sequence
			. zeroOrMore characterExcept
				. syntax.string
				. syntax.function
				. syntax.unixNewLine
			. sequence character syntax.function
			. expression
		result
			arg|
				parsed
					[codeKeys.parameterName] arg.parsed.[1]
					[codeKeys.expression] arg.parsed.[3]
	lookupAnythingExpression rule
		condition sequence
			. character syntax.lookupStart
			. expression
			. zeroOrMore character syntax.indentation
			. character syntax.lookupEnd
		result
			arg|
				parsed arg.parsed.[2]
	lookupStringExpression rule
		condition lookupString
		result
			arg|
				parsed
					[codeKeys.literal] arg.parsed
	search rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		result
			arg|
				parsed
					[codeKeys.search] arg.parsed
	root rule
		condition character syntax.root
		result
			arg|
				parsed
					[codeKeys.root] 0
	ruleCurrent rule
		condition stringRule syntax.mapCurrent
		result
			|
				parsed
					["current"] 0
	realLookup rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		result
			arg|
				parsed
					[codeKeys.lookup] arg.parsed
	lookup alternatives
		. ruleCurrent
		. realLookup
	select rule
		condition sequence
			. rule
				condition alternatives
					. root
					. search
					. lookup
				result
					arg|
						parsed
							. arg.parsed
			. zeroOrMore rule
				condition sequence
					. character syntax.select
					. lookup
				result
					arg|
						parsed arg.parsed.[2]
		result
			arg|
				parsed
					[codeKeys.select] join arg.parsed
	functionExpression rule
		condition function
		result
			arg|
				parsed
					[codeKeys.key]
						.
							[codeKeys.lookup]
								[codeKeys.literal] codeKeys.function
					[codeKeys.value]
						[codeKeys.literal] arg.parsed
	statement alternatives
		. functionExpression
		. rule
			condition sequence
				. keys
				. optional character syntax.assignment
				. expression
				. endOfLine
			result
				arg|
					parsed
						[codeKeys.key] arg.parsed.[1]
						[codeKeys.value] arg.parsed.[3]
	program rule
		condition sequence
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequence
				. indentation
				. rule
					condition statement
					result
						arg|
							parsed
								. arg.parsed
				. zeroOrMore sequence
					. alternatives
						. sameIndentation
						. dedentation
					. statement
			. 
				parser|"p.defaultKeys.Pop 0"
		result
			arg|
				parsed
					[codeKeys.program] arg.parsed.[2]
	call rule
		condition sequence
			. select
			. alternatives
				. rule
					condition sequence
						. alternatives
							. character syntax.call
							. character syntax.indentation
						. expression
					result
						arg|
							parsed arg.parsed.[2]
				. program
		result
			arg|
				parsed
					[codeKeys.call] 
						[codeKeys.callable] arg.parsed.[1]
						[codeKeys.argument] arg.parsed.[2]
	whitespace zeroOrMore alternatives
		. character syntax.tab
		. character syntax.space
	emptyMap rule
		condition character syntax.emptyMap
		result
			|
				parsed 0
	literalExpression rule
		condition alternatives
			. emptyMap
			. string
			. number
			. characterDataExpression
		result
			arg|
				parsed
					[codeKeys.literal] arg.parsed
	keysSearch rule
		condition sequence
			. character syntax.search
			. search
		result
			arg|
				parsed arg.parsed.[2]
	autokeyLookup rule
		condition character syntax.autokey
		result
			arg|
				defaultKey add
					. arg.defaultKey
					. 1
				parsed
					[codeKeys.lookup]
						[codeKeys.literal] arg.defaultKey
	makeList
		subRule|rule
			condition subRule
			result
				arg|
					parsed
						. arg.parsed
	keys rule
		condition sequence
			. makeList alternatives
				. keysSearch
				. lookup
				. autokeyLookup
			. zeroOrMore rule
				condition sequence
					. character syntax.select
					. lookup
				result
					arg|
						parsed arg.parsed.[2]
		result
			arg|
				parsed join arg.parsed
	current /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer number
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest literalExpression 
				text "
					"hello"
				"
			characterTest literalExpression 
				text "'a'"
			emptyMapTest literalExpression 
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
		searchTest search
			text "hello"
		rootTest root
			text "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent
				text "current"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest select
				text "hello"
			severalTest select
				text "hello.hello"
			complexTest select
				text"
					hello.["world"]
				"
		keysSearchTest
			simple keysSearch
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
				one dedentation
					text "		"
					indentationCount 1
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest "
			string
				text "
					"
						hello hello hello
						hello
						hello hello
					"
				"
		"