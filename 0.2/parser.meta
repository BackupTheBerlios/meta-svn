parser|
	success
		value|(defaultFunction
			arg|if (@.function value)
				then
					|arg.then value
				else
					|arg.else value)
			then
				|@
			else
				|0
			function
				|hasKey @ "parsed"
	baseRule (defaultFunction
		arg|
			parser|success (arg.condition parser)
				then
					|merge (merge parser (merge @ (arg.result (merge parser @))))
						parsed arg.parse @.parsed)
		result
			|0
		parse
			|@
		indenting
			|@
	rule
		condition|
			parse|baseRule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|baseRule
				condition condition
				result result
	matchChar
		compare|
			mod|(rule
				parser|if (and
					.
						|not (null parser.text)
					. 
						|compare
							char parser.text.[1]
							mod mod)
					then
						|
							parsed parser.text.[1]
							text rest parser.text) 0
	character matchChar
		|equal @.mod @.char
	characterSet matchChar
		|contains @.mod @.char
	characterExcept matchChar
		|not (contains @.mod @.char)
	loopRule
		arg|(rule
			parser|
				implementation
					impArg|if (arg.tooMuch
						count add impArg.n 1
						parser impArg.parser)
						then
							|impArg.parser
						else
							|success (arg.rule impArg.parser)
								then
									res|success (implementation
										parser res
										n add impArg.n 1)
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (not (arg.tooFew
										count impArg.n
										parser impArg.parser))
										then
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0
	nTimes
		loopedRule|
			n|loopRule
				tooMuch
					@|smaller (n @.parser) @.count
				tooFew
					@|smaller @.count (n @.parser)
				rule loopedRule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|greater 1 arg.count
			rule arg
	sequence
		first|
			second|
				parser|success (first parser)
					then
						a|success (second a)
							then
								b|merge parser (merge b
									parsed
										[1] a.parsed
										[2] b.parsed)
	alternative
		first|
			second|
				parser|success (first parser)
					else
						|success (second parser) 0
	optional
		mod|
			parser|merge parser (mod parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	syntax
		charDelimiter character 39
		char characterExcept 39
		linefeed character 10
		carriageReturn character 13
		whitespace characterSet
			. 9
			. ' '
		indentation character 9
		string character '"'
		stringLineText characterExcept
			. 10
			. 13
			. '"'
		lookupStart character '['
		lookupEnd character ']'
		function character '|'
		root character '/'
		current character ':'
		select character '.'
		tab character 9
		space character ' '
		emptyMap character '0'
		search character '$'
	number rule (oneOrMore (characterSet "0123456789"))
		|/.Meta.Number.Parse @
	newLine alternative syntax.linefeed (sequence syntax.carriageReturn syntax.linefeed)
	whitespace zeroOrMore syntax.whitespace
	endOfLine sequence whitespace newLine
	indentRule
		change|generalRule (nTimes syntax.indentation
			|add @.indentationCount change)
			|
				indentationCount add @.indentationCount change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	prefix
		prefixRule|
			realRule|rule (sequence prefixRule realRule)
				|@.[2]
	suffix
		suffixRule|
			realRule|rule (sequence realRule suffixRule)
				|@.[1]
	characterDataExpression prefix syntax.charDelimiter (suffix syntax.charDelimiter syntax.char)
	stringLine zeroOrMore syntax.stringLineText
	string suffix (sequence (optional newLine) (optional syntax.string)) (prefix syntax.string (alternative (oneOrMore syntax.stringLineText) (prefix (sequence newLine indentation) stringLine)))
	lookupString oneOrMore lookupForbidden
	delayed
		mod|
			parser|mod 0 parser
	value delayed
		|alternative number (alternative characterDataExpression (alternative string map))
	lookupAnything prefix syntax.lookupStart (suffix (sequence (zeroOrMore 9) syntax.lookupEnd) value)
	entry delayed
		|rule (alternative function (rule (alternative (alternative (lookupString lookupAnything)) (alternative (prefix (oneOrMore syntax.whitespace) value) map)))
			|
				[@.[1]] @.[2]) 0
	entry delayed
		|rule (alternative functionRule (rule (sequence (alternative lookupString lookupAnything) (alternative (prefix (oneOrMore syntax.whitespace) value) map))
			|
				[@.[1]] @.[2])) 0
	onePlusX
		arg|(rule (sequence (rule arg.first
			|
				. @) (zeroOrMore (baseRule
			condition prefix arg.delimiter arg.step))))
			|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	expression delayed
		|alternative literalExpression (alternative characterDataExpression (alternative emptyMap select))
	lookupAnythingExpression suffix (sequence (zeroOrMore syntax.indentation) syntax.lookupEnd) (prefix syntax.lookupStart expression)
	lookupStringExpression rule lookupString
		|
			literal @
	search rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			search @
	root rule syntax.root
		|
			root 0
	ruleCurrent rule syntax.current
		|
			["current"] 0
	realLookup rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			lookup @
	lookup alternative ruleCurrent realLookup
	select (rule (onePlusX
		first alternative root (alternative search lookup)
		delimiter syntax.select
		step lookup))
		|
			select @
	functionRule rule (sequence (zeroOrMore (characterExcept
		. ' '
		. 10
		. '|')) (sequence syntax.function select))
		|
			parameter @.[1]
			expression @.[2].[2]
	functionExpression rule functionRule
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	normalStatement rule (sequence keys (sequence whitespace (sequence expression endOfLine)))
		|
			key @.[1]
			value @.[2].[2].[1]
	statement alternative functionExpression normalStatement
	program "
		(rule (sequences
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequences
				. indentation
				. onePlusX
					first statement
					step statement
					delimiter sameIndentation
				. dedentation
			. 
				parser|"p.defaultKeys.Pop 0"))
			|
				program @.[2]
	"
	call rule (sequence select (alternative (prefix (oneOrMore (alternative syntax.space syntax.tab)) expression) program))
		|
			call @
	emptyMap rule syntax.emptyMap
		|0
	literalExpression (rule (alternative emptyMap (alternative string (alternative number characterDataExpression))))
		|
			literal @
	keysSearch prefix syntax.search search
	autokeyLookup generalRule syntax.select
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keys onePlusX
		first alternative keysSearch (alternative lookup autokeyLookup)
		delimiter syntax.select
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine expression
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer expression
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest expression
				text "
					"hello"
				"
			characterTest expression
				text "'a'"
			emptyMapTest expression
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
			complex lookupAnythingExpression
				text "[[hello]]"
		searchTest search
			text "hello"
		rootTest expression
			text "/"
		ruleCurrentTest 
			shouldMatch expression
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest expression
				text "hello"
			severalTest expression
				text "hello.hello"
			complexTest expression
				text"
					hello.["world"]
				"
		keysSearchTest
			simple expression
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0
		autokeyLookupTest autokeyLookup
			text "."
			defaultKey 1
		functionTest
			simple functionRule
				text "asdf|hello"
		functionTest
			simple functionExpression
				text "asdf|hello"
		valueTest
			stringTest value 
				text "
					"hello"
				"
				indentationCount 0
			numberTest value
				text "0928341"
			characterTest value
				text "'c'"
		entryTest 
			simple entry
				text "
					asdf "hello"
				"
				indentationCount 0
			functionTest entry
				text "asdf|hello"
		mapTest
			simple map
				text "
					asdf "hello"
					qwerty "hi"
				"
				indentationCount 0