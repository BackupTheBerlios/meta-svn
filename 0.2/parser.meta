parser|
	conditional defaultFunction
		function
			arg|if (arg.function arg.value)
				then
					|arg.then arg.value
				else
					|arg.else arg.value
		argument
			else
				|0
			function
				|hasKey @ "parsed"
	rule defaultFunction
		function
			arg|
				parser|conditional
					value arg.condition parser
					then
						|merge (merge parser (merge @ (arg.result (merge parser @))))
							parsed arg.parse @.parsed
		argument
			result
				|0
			parse
				|@
			indenting
				|@
	specialRule
		condition|
			parse|rule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|rule
				condition condition
				result result
	matchChar
		compare|(specialRule
			parser|if (and
				.
					|not (null parser.text)
				. 
					|compare parser.text.[1])
				then
					|
						parsed parser.text.[1]
						text rest parser.text) 0
	character
		char|matchChar
			|equal char @
	characterSet
		chars|matchChar
			|contains chars @
	characterExcept
		chars|matchChar
			|not (contains chars @)
	loopRule
		arg|(specialRule
			parser|
				implementation
					impArg|if (arg.tooMuch
						count add impArg.n 1
						parser impArg.parser)
						then
							|impArg.parser
						else
							|conditional
								value arg.rule impArg.parser
								then
									res|conditional
										value implementation
											parser res
											n add impArg.n 1
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (not (arg.tooFew
										count impArg.n
										parser impArg.parser))
										then
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0
	nTimes
		arg|loopRule
			tooMuch
				@|smaller (arg.n @.parser) @.count
			tooFew
				@|smaller @.count (arg.n @.parser)
			rule arg.rule
	zeroOrMore
		looped|loopRule
			tooMuch
				|0
			tooFew
				|0
			rule looped
	oneOrMore
		arg|loopRule
			tooMuch
				|0
			tooFew
				arg|greater 1 arg.count
			rule arg
	sequence
		rules|rule
			condition
				parser|implementation
					parser parser
					rules rules
		implementation
			arg|if (hasKey arg.rules 1)
				then
					|conditional
						value arg.rules.[1] arg.parser
						then
							ruleResult|conditional
								value implementation
									parser
										parsed 0
										text ruleResult.text
										indentationCount 0
									rules rest arg.rules
								then
									|
										text @.text
										parsed prepend ruleResult.parsed @.parsed
								else
									|@
				else
					|arg.parser
	alternatives
		alts|rule
			condition
				parser|
					implementation
						arg|if (not (equal arg 0))
							then
								|conditional
									value arg.[1] parser
									then
										|@
									else
										|implementation (rest arg)
					: implementation alts
	alternatives
		alts|rule
			condition
				parser|
					implementation
						arg|if (not (equal arg 0))
							then
								|conditional
									value arg.[1] parser
									then
										|@
									else
										|implementation (rest arg)
					: implementation alts
	optional
		subRule|
			parser|merge parser (subRule parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	number rule
		condition oneOrMore (characterSet "0123456789")
		parse
			|/.Meta.Number.Parse @
	newLine alternatives
		. character 10
		. sequence
			. character 13
			. character 10
	whitespace zeroOrMore (characterSet
		. 9
		. ' ')
	endOfLine sequence
		. whitespace
		. newLine
	indentRule
		change|generalRule (nTimes
			n
				|add @.indentationCount change
			rule character 9)
			|
				indentationCount add @.indentationCount change
	indentation indentRule 1
	sameIndentation indentRule 0
	dedentation indentRule -1
	stringLine zeroOrMore (characterExcept
		. 10
		. 13
		. '"')
	prefix
		prefixRule|
			realRule|rule
				condition sequence
					. prefixRule
					. realRule
				parse
					|@.[2]
	suffix
		suffixRule|
			realRule|rule
				condition sequence
					. realRule
					. suffixRule
				parse
					|@.[1]
	characterDataExpression prefix (character 39) (suffix (character 39) (characterExcept
		. 39))
	string suffix (sequence
		. optional newLine
		. optional (character '"')) (prefix (character '"') (alternatives
		. oneOrMore (characterExcept
			. 10
			. 13
			. '"')
		. sequence
			. prefix (sequence
				. newLine
				. indentation) stringLine))
	lookupString oneOrMore lookupForbidden
	value
		parser|
			rule alternatives
				. map
				. string
				. number
				. characterDataExpression
			: rule parser.text
	lookupAnything prefix (character '[') (suffix (sequence
		. zeroOrMore 9
		. character ']') value)
	entry (specialRule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. whitespace
			. value)
		|
			[@.[2]] @.[4]
	onePlusX
		arg|(specialRule (sequence
			. specialRule arg.first
				|
					. @
			. zeroOrMore (rule
				condition prefix arg.delimiter arg.step)))
			|join @
	mapCore onePlusX
		first entry
		delimiter sameIndentation
		step entry
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	expression
		parser|
			localRule rule
				condition alternatives
					. literalExpression
			: localRule
				text parser.text
	function (specialRule (sequence
		. zeroOrMore (characterExcept
			. '"'
			. ' '
			. 10)
		. character '|'
		. expression))
		|
			parameter @.[1]
			expression @.[3]
	lookupAnythingExpression suffix (sequence
		. zeroOrMore (character 9)
		. character ']') (prefix (character '[') expression)
	lookupStringExpression specialRule lookupString
		|
			literal @
	search (specialRule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression))
		|
			search @
	root specialRule (character '/')
		|
			root 0
	ruleCurrent specialRule (character ':')
		|
			["current"] 0
	realLookup (specialRule (alternatives
		. lookupStringExpression
		. lookupAnythingExpression))
		|
			lookup @
	lookup alternatives
		. ruleCurrent
		. realLookup
	select (specialRule (onePlusX
		first alternatives
			. root
			. search
			. lookup
		delimiter character '.'
		step lookup))
		|
			select @
	functionExpression specialRule function
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	statement alternatives
		. functionExpression
		. specialRule (sequence
			. keys
			. whitespace
			. expression
			. endOfLine)
			|
				key @.[1]
				value @.[3]
	program (specialRule (sequence
		.
			parser|
				. "p.defaultKeys.Push 1"
				parsed 0
				text parser.text.text
		. sequence
			. indentation
			. rule
				condition statement
				parse
					|
						. @
			. zeroOrMore sequence
				. alternatives
					. sameIndentation
					. dedentation
				. statement
		. 
			parser|"p.defaultKeys.Pop 0"))
		|
			program @.[2]
	call (specialRule (sequence
		. select
		. alternatives
			. prefix (sequence
				. alternatives
					. character ' '
					. character 9) expression
			. program))
		|
			call
				callable @.[1]
				argument @.[2]
	emptyMap specialRule (character '0')
		|0
	literalExpression (specialRule (alternatives
		. emptyMap
		. string
		. number
		. characterDataExpression))
		|
			literal @
	keysSearch prefix (character '$') search
	autokeyLookup generalRule (character '.')
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keys onePlusX
		first alternatives
			. keysSearch
			. lookup
			. autokeyLookup
		delimiter character '.'
		step lookup
	: /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer number
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest literalExpression 
				text "
					"hello"
				"
			characterTest literalExpression 
				text "'a'"
			emptyMapTest literalExpression 
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
		searchTest search
			text "hello"
		rootTest root
			text "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest select
				text "hello"
			severalTest select
				text "hello.hello"
			complexTest select
				text"
					hello.["world"]
				"
		keysSearchTest
			simple keysSearch
				text "$hello"
		keysTest
			simple keys
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "	"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "			"
					indentationCount 2
				one sameIndentation
					text "		"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0