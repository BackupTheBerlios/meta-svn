parser|
	success
		value|(defaultFunction
			arg|if (@.function value)
				then
					|arg.then value
				else
					|arg.else value)
			then
				|@
			else
				|0
			function
				|hasKey @ "parsed"
	baseRule (defaultFunction
		arg|
			parser|success (arg.condition parser)
				then
					|merge (merge parser (merge @ (arg.result (merge parser @))))
						parsed arg.parse @.parsed)
		result
			|0
		parse
			|@
		indenting
			|@
	rule
		condition|
			parse|baseRule
				condition condition
				parse (merge
					|@) parse
	generalRule
		condition|
			result|baseRule
				condition condition
				result result
	charRule
		compare|
			mod|(rule
				parser|if (and
					.
						|not (equal 0 parser.text)
					. 
						|compare parser.text.[1] mod)
					then
						|
							parsed parser.text.[1]
							text rest parser.text) 0
	character charRule
		char|
			mod|equal mod char
	characterSet charRule
		char|
			mod|contains mod char
	characterExcept charRule
		char|
			mod|not (contains mod char)
	loopRule (defaultFunction
		arg|(rule
			parser|
				implementation
					impArg|if (arg.tooMuch impArg.parser (add impArg.n 1))
						then
							|impArg.parser
						else
							|success (arg.rule impArg.parser)
								then
									res|success (implementation
										parser res
										n add impArg.n 1)
										then
											nextResult|
												parsed prepend res.parsed nextResult.parsed
												text nextResult.text
												indentationCount if (hasKey nextResult "indentationCount")
													then
														|nextResult.indentationCount
								else
									res|if (arg.tooFew impArg.parser impArg.n)
										else
											|impArg.parser
				: implementation
					parser merge parser
						parsed 0
					n 0) 0)
		tooMuch
			|
				|0
		tooFew
			|
				|0
	nTimes
		loopedRule|
			n|loopRule
				tooMuch
					parser|
						count|smaller (n parser) count
				tooFew
					parser|
						count|smaller count (n parser)
				rule loopedRule
	zeroOrMore
		looped|loopRule
			rule looped
	oneOrMore
		arg|loopRule
			tooFew
				parser|
					count|greater 1 count
			rule arg
	sequence
		first|
			second|
				parser|success (first parser)
					then
						a|success (second a)
							then
								b|merge parser (merge b
									parsed
										. a.parsed
										. b.parsed)
	alternative
		first|
			second|
				parser|success (first parser)
					else
						|success (second parser) 0
	optional
		mod|
			parser|merge parser (mod parser)
	lookupForbidden characterExcept
		. ' '
		. 9
		. 13
		. 10
		. '.'
		. '['
		. ']'
	syntax
		charDelimiter character 39
		char characterExcept 39
		linefeed character 10
		carriageReturn character 13
		whitespace characterSet
			. 9
			. ' '
		indentation character 9
		string character '"'
		stringLineText characterExcept
			. 10
			. 13
			. '"'
		longStringLineText characterExcept
			. 10
			. 13
		lookupStart character '['
		lookupEnd character ']'
		function character '|'
		root character '/'
		current character ':'
		select character '.'
		tab character 9
		space character ' '
		emptyMap character '0'
		search character '$'
		callStart character '('
		callEnd character ')'
	onePlusX
		arg|(rule (sequence (rule arg.first
			|
				. @) (zeroOrMore (baseRule
			condition prefix arg.delimiter arg.step))))
			|sum @ join
	number rule (oneOrMore (characterSet "0123456789"))
		|/.Meta.StrategyMap.[/.Meta.Number] (/.Meta.Number.Parse.[/.mscorlib.String] @)
	newLine alternative syntax.linefeed (sequence syntax.carriageReturn syntax.linefeed)
	whitespace zeroOrMore syntax.whitespace
	endOfLine sequence whitespace newLine
	indentRule
		change|generalRule (nTimes syntax.indentation
			|add @.indentationCount change)
			|
				indentationCount add @.indentationCount change
	indentation sequence endOfLine (indentRule 1)
	sameIndentation sequence endOfLine (indentRule 0)
	dedentation indentRule -1
	prefix
		prefixRule|
			realRule|rule (sequence prefixRule realRule)
				|@.[2]
	suffix
		suffixRule|
			realRule|rule (sequence realRule suffixRule)
				|@.[1]
	characterDataExpression prefix syntax.charDelimiter (suffix syntax.charDelimiter syntax.char)
	stringLine zeroOrMore syntax.stringLineText
	longStringLine zeroOrMore syntax.longStringLineText
	longString rule (onePlusX
		first longStringLine
		delimiter sameIndentation
		step longStringLine)
		|sum @
			first|
				second|join first ((join 
					. 10) second)
	string suffix (optional syntax.string) (prefix syntax.string (alternative (oneOrMore syntax.stringLineText) longString))
	lookupString oneOrMore lookupForbidden
	delayed
		mod|
			parser|mod 0 parser
	value delayed
		|alternative number (alternative characterDataExpression (alternative string map))
	lookupAnything prefix syntax.lookupStart (suffix (sequence (zeroOrMore 9) syntax.lookupEnd) value)
	entry delayed
		|rule (alternative function (rule (alternative (alternative (lookupString lookupAnything)) (alternative (prefix (oneOrMore syntax.whitespace) value) map)))
			|
				[@.[1]] @.[2]) 0
	entry delayed
		|rule (alternative functionRule (rule (sequence (alternative lookupString lookupAnything) (alternative (prefix (oneOrMore syntax.whitespace) value) map))
			|
				[@.[1]] @.[2])) 0
	mapCore rule (onePlusX
		first entry
		delimiter sameIndentation
		step entry)
		|sum @ merge
	map suffix dedentation (prefix indentation mapCore)
	file mapCore
	alternatives
		alts|sum alts alternative
	expression delayed
		|alternatives
			. literalExpression
			. characterDataExpression
			. emptyMap
			. select
	lookupAnythingExpression suffix (sequence (zeroOrMore syntax.indentation) syntax.lookupEnd) (prefix syntax.lookupStart expression)
	lookupStringExpression rule lookupString
		|
			literal @
	search rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			search @
	root rule syntax.root
		|
			root 0
	ruleCurrent rule syntax.current
		|
			current 0
	realLookup rule (alternative lookupStringExpression lookupAnythingExpression)
		|
			lookup @
	lookup alternative ruleCurrent realLookup
	select (rule (onePlusX
		first alternatives
			. root 
			. search
			. lookup
		delimiter syntax.select
		step lookup))
		|
			select @
	functionRule rule (sequence (zeroOrMore (characterExcept
		. ' '
		. 10
		. '|')) (sequence syntax.function select))
		|
			parameter @.[1]
			expression @.[2].[2]
	functionExpression rule functionRule
		|
			key
				.
					lookup
						literal "function"
			value
				literal @
	keysSearch prefix syntax.search search
	autokeyLookup generalRule syntax.select
		|
			defaultKey add @.defaultKey 1
			parsed
				lookup
					literal @.defaultKey
	keysRule onePlusX
		first alternatives 
			. keysSearch 
			. lookup
			. autokeyLookup
		delimiter syntax.select
		step lookup
	normalStatement rule (sequence keysRule (sequence whitespace expression))
		|
			key @.[1]
			value @.[2].[2]
	statement alternative functionExpression normalStatement
	program "
		(rule (sequences
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser.text.text
			. sequences
				. indentation
				. onePlusX
					first statement
					step statement
					delimiter sameIndentation
				. dedentation
			. 
				parser|"p.defaultKeys.Pop 0"))
			|
				program @.[2]
	"
	program rule (suffix dedentation (prefix indentation (onePlusX
		first statement
		step statement
		delimiter sameIndentation)))
		|
			program @
	call rule (sequence select (alternative (prefix (oneOrMore (alternative syntax.space syntax.tab)) expression) program))
		|
			call @
	explicitCall suffix syntax.callEnd (prefix syntax.callStart call)
	emptyMap rule syntax.emptyMap
		|0
	literalExpression rule (alternatives
		. emptyMap
		. string
		. number
		. characterDataExpression)
		|
			literal @
	: /.Meta.Serialize.ValueFunction.[/.Meta.Map]
		stringTest
			singleLine expression
				text "
					"12344321 asdfasdf"
				"
		numberTest
			integer expression
				text "483821"
		lookupStringTest
			simple lookupStringExpression
				text "hello"
			shouldPartlyMatch lookupStringExpression
				text "hello.hello"
		expressionTest
			stringTest expression
				text "
					"hello"
				"
		literalTest
			stringTest expression
				text "
					"hello"
				"
			characterTest expression
				text "'a'"
			emptyMapTest expression
				text "0"
		lookupAnythingTest
			simple lookupAnythingExpression
				text "
					["hello"]
				"
			complex lookupAnythingExpression
				text "[[hello]]"
		searchTest search
			text "hello"
		rootTest expression
			text "/"
		ruleCurrentTest 
			shouldMatch expression
				text ":"
			shouldNotMatch ruleCurrent
				text "hello"
		lookupTest lookup
			text "hello"
		selectTest
			singleTest expression
				text "hello"
			severalTest expression
				text "hello.hello"
			complexTest expression
				text"
					hello.["world"]
				"
		keysSearchTest
			simple expression
				text "$hello"
		keysTest
			simple keysRule
				text "hello.hello"
		callTest
			simple call
				text "
					hello "hi"
				"
			explicitCall explicitCall
				text "
					(hello "hi")
				"
		endOfLineTest
			unix
				shouldMatch endOfLine
					text
						. 10
				shouldNotMatch endOfLine
					text "hello"
			windows 
				shouldMatch endOfLine
					text 
						. 13
						. 10
				shouldNotMatch endOfLine
					text "hello"
		whitespaceTest
			shouldMatch whitespace
				text "					 "
			shouldNotMatch whitespace
				text "			kj	"
		indentationTest
			shouldMatch indentation
				text "
					
						
				"
				indentationCount 0
		dedentationTest
			shouldMatch
				two dedentation
					text "			"
					indentationCount 2
					parsed 0
				one dedentation
					text "		"
					indentationCount 1
					parsed 0
			shouldNotMatch dedentation
				text "		"
				indentationCount 5
				parsed 0
		sameIndentationTest
			shouldMatch
				two sameIndentation
					text "
						
									
					"
					indentationCount 2
				one sameIndentation
					text "
						
								
					"
					indentationCount 1
			shouldNotMatch sameIndentation
				text "		"
				indentationCount 5
		stringLineTest stringLine
			text "
				hello hello hello
				hi hi
			"
		longStringTest 
			simple string
				text "
					"
						hello hello hello
					"
				"
				indentationCount 0
				parsed 0
			longer string
				text "
					"
						hello
						hello
						hello
					"
				"
				indentationCount 0
				parsed 0
		autokeyLookupTest autokeyLookup
			text "."
			defaultKey 1
		functionTest
			simple functionRule
				text "asdf|hello"
		functionTest
			simple functionExpression
				text "asdf|hello"
		valueTest
			stringTest value 
				text "
					"hello"
				"
				indentationCount 0
			numberTest value
				text "0928341"
			characterTest value
				text "'c'"
		entryTest 
			simple entry
				text "
					asdf "hello"
				"
				indentationCount 0
			functionTest entry
				text "asdf|hello"
		mapTest
			simple map
				text "
					
						asdf "hello"
						qwerty "hi"
						hi "hello"
				"
				indentationCount 0
		statementTest
			simple statement
				text "
					asdf "hello"
				"
				indentationCount 0
		programTest
			simple program
				text "
					
						asdf "hello"
						qwerty "hi"
						hi "hello"
				"
				indentationCount 0
		basicTest "
			file
				text "
					license "
						Copyright (c) 2005, 2006 Christian Staudenmeyer
						
						Permission is hereby granted, free of charge, to any person obtaining
						a copy of this software and associated documentation files (the
						"Software"), to deal in the Software without restriction, including
						without limitation the rights to use, copy, modify, merge, publish,
						distribute, sublicense, and/or sell copies of the Software, and to
						permit persons to whom the Software is furnished to do so, subject to
						the following conditions:
						
						The above copyright notice and this permission notice shall be
						included in all copies or substantial portions of the Software.
						
						THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
						EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
						MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
						NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
						BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
						ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
						CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
						SOFTWARE.
					"
					commandLine|
						asdf "hello"
						shortFunction
							arg|asdf
						shortFunctionTest shortFunction "hello"
						counter 0
				"
				indentationCount 0
		"