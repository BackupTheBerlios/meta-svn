integer "0123456789"
codeKeys
	parameterName "parameterName"
	root "root"
	search "search"
	lookup "lookup"
	current "current"
	scope "scope"
	literal "literal"
	function "function"
	call "call"
	callable "callable"
	argument "argument"
	select "select"
	program "program"
	key "key"
	value "value"
	expression "expression"
parser|
	syntax
		autokey '.'
		callStart '('
		callEnd ')'
		root '/'
		search '$'
		negative '-'
		fraction '/'
		endOfFile 65535
		indentation 9
		unixNewLine 10
		function '|'
		string '"'
		lookupStart '['
		lookupEnd ']'
		emptyMap '0'
		call ' '
		select '.'
		character 39
		assignment ' '
		space ' '
		tab 9
		mapCurrent "current"
		integer "0123456789"
		windowsNewLine
			. 13
			. 10
		lookupStringForbidden
			. call
			. indentation
			. 13
			. 10
			. assignment
			. select
			. function
			. string
			. lookupStart
			. lookupEnd
			. emptyMap
			. search
			. root
			. callStart
			. callEnd
			. character
	number rule
		condition oneOrMore characterSet syntax.integer
		result
			parser|/.Meta.Number.Parse parser
	untested "!!!!!!"
	newline alternatives
		. character syntax.unixNewLine
		. stringRule syntax.windowsNewLine
	endOfLine sequence
		. zeroOrMore alternatives
			. character syntax.space
			. character syntax.tab
		. newline
	startOfFile 1
	indentationCount 0
	indentation rule
		condition sequence
			. endOfLine
			. 
				parser|nTimes
					n add
						. indentationCount
						. 1
					rule character syntax.indentation
		result
			|
				$indentationCount add
					. indentationCount
					. 1
	indentation rule
		condition
			parser|if
				condition startOfFile
				then
					|
						parsed 0
						text parser
		result
			|"hello"
	sameIndentation
		|nTimes
			n indentationCount
			rule character syntax.indentation
	stringLine zeroOrMore characterExcept
		. syntax.unixNewLine
		. syntax.windowsNewLine.[1]
	stringDedentation 
		rule sequence
			. endOfLine
			. |nTimes
				n subtract
					. indentationCount
					. 1
				rule character syntax.indentation
		result
			|
				$indentationCount subtract
					. indentationCount
					. 1
	characterDataExpression prePost
		pre character syntax.character
		rule characterExcept
			. syntax.character
		post character syntax.character
	string prePost
		pre syntax.string
		rule alternatives
			. oneOrMore characterExcept
				. syntax.unixNewLine
				. syntax.windowsNewLine.[1]
				. syntax.string
			. prePost
				pre indentation
				rule sequence
					. stringLine
					. zeroOrMore
						. endOfLine
						. sameIndentation
						. sequence
							. character syntax.unixNewLine
							. stringLine
				post stringDedentation
		post syntax.string
	string prePost
		pre character syntax.string
		rule zeroOrMore characterExcept
			. syntax.string
		post character syntax.string
	lookupString oneOrMore characterExcept syntax.lookupStringForbidden
	value
		parser|
			rule alternatives
				. map
				. string
				. number
				. characterDataExpression
			current rule parser
	lookupAnything rule
		condition sequence
			. character syntax.lookupStart
			. value
			. zeroOrMore syntax.indentation
			. character syntax.lookupEnd
		result
			arg|arg.[2]
	entry rule
		condition sequence
			. function
			. alternatives
				. lookupString
				. lookupAnything
			. optional character syntax.assignment
			. value
		result
			arg|
				[arg.[2]] arg.[4]
	dedentation rule
		condition
			|
				parsed 0
		result
			|
				$indentationCount subtract
					. indentationCount
					. 1
	mapCore sequence
		. rule
			condition entry
			result
				arg|
					. arg
		. oneOrMore rule
			condition sequence
				. sameIndentation
				. entry
			result
				arg|arg.[2]
	map prePost
		pre indentation
		rule mapCore
		post dedentation
	file mapCore
	expression
		parser|
			localRule rule
				condition alternatives
					. literalExpression
				result
					arg|arg
			current localRule parser
	function rule
		condition sequence
			. zeroOrMore characterExcept
				. syntax.string
				. syntax.function
				. syntax.unixNewLine
			. sequence character syntax.function
			. expression
		result
			arg|
				[codeKeys.parameterName] arg.[1]
				[codeKeys.expression] arg.[3]
	lookupAnythingExpression rule
		condition sequence
			. character syntax.lookupStart
			. expression
			. zeroOrMore character syntax.indentation
			. character syntax.lookupEnd
		result
			arg|arg.[2]
	lookupStringExpression rule
		condition lookupString
		result
			arg|
				[codeKeys.literal] arg
	search rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		result
			arg|
				[codeKeys.search] arg
	root rule
		condition character syntax.root
		result
			arg|
				[codeKeys.root] 0
	ruleCurrent rule
		condition stringRule syntax.mapCurrent
		result
			|
				["current"] 0
	realLookup rule
		condition alternatives
			. lookupStringExpression
			. lookupAnythingExpression
		result
			arg|
				[codeKeys.lookup] arg
	lookup alternatives
		. ruleCurrent
		. realLookup
	select rule
		condition sequence
			. rule
				condition alternatives
					. root
					. search
					. lookup
				result
					arg|
						. arg
			. zeroOrMore rule
				condition sequence
					. character syntax.select
					. lookup
				result
					arg|arg.[2]
		result
			arg|
				[codeKeys.select] join arg
	functionExpression rule
		condition function
		result
			arg|
				[codeKeys.key]
					.
						[codeKeys.lookup]
							[codeKeys.literal] codeKeys.function
				[codeKeys.value]
					[codeKeys.literal] arg
	statement alternatives
		. functionExpression
		. rule
			condition sequence
				. keys
				. optional character syntax.assignment
				. expression
				. endOfLine
			result
				arg|
					[codeKeys.key] arg.[1]
					[codeKeys.value] arg.[3]
	program rule
		condition sequence
			.
				parser|
					. "p.defaultKeys.Push 1"
					parsed 0
					text parser
			. sequence
				. indentation
				. rule
					condition statement
					result
						arg|
							. arg
				. zeroOrMore sequence
					. alternatives
						. sameIndentation
						. dedentation
					. statement
			. 
				parser|"p.defaultKeys.Pop 0"
		result
			arg|
				[codeKeys.program] arg.[2]
	call rule
		condition sequence
			. select
			. alternatives
				. rule
					condition sequence
						. alternatives
							. character syntax.call
							. character syntax.indentation
						. expression
					result
						arg|arg.[2]
				. program
		result
			arg|
				[codeKeys.call] 
					[codeKeys.callable] arg.[1]
					[codeKeys.argument] arg.[2]
	whitespace zeroOrMore alternatives
		. character syntax.tab
		. character syntax.space
	emptyMap rule
		condition character syntax.emptyMap
		result
			|0
	literalExpression rule
		condition alternatives
			. emptyMap
			. string
			. number
			. characterDataExpression
		result
			arg|
				[codeKeys.literal] arg
	keysSearch rule
		condition sequence
			. character syntax.search
			. search
		result
			arg|arg.[2]
	autokeyLookup
		rule character syntax.autokey
		result
			|
				$defaultKeys push.Push
					. p.defaultKeys.Pop 0
					. 1
				current 
					[codeKeys.lookup]
						[codeKeys.literal] last defaultKeys
	makeList
		subRule|rule
			condition subRule
			result
				arg|
					. arg
	keys rule
		condition sequence
			. makeList alternatives
				. keysSearch
				. lookup
				. autokeyLookup
			. zeroOrMore rule
				condition sequence
					. character syntax.select
					. lookup
				result
					arg|arg.[2]
		result
			arg|join arg
	untested "!!!!!!"
	stringCharacter characterExcept
		. syntax.string
	testRule zeroOrMore characterExcept
		. '.'
	current /.Meta.Serialize.ValueFunction
		stringTest
			singleLine string "
				"12344321 asdfasdf"
			"
		numberTest
			integer number "483821"
		lookupStringTest
			simple lookupStringExpression "hello"
			shouldPartlyMatch lookupStringExpression "hello.hello"
		expressionTest
			stringTest expression "
				"hello"
			"
		literalTest
			stringTest literalExpression "
				"hello"
			"
			characterTest literalExpression "'a'"
			emptyMapTest literalExpression "0"
		lookupAnythingTest
			simple lookupAnythingExpression "
				["hello"]
			"
		searchTest search "hello"
		rootTest root "/"
		ruleCurrentTest 
			shouldMatch ruleCurrent "current"
			shouldNotMatch ruleCurrent "hello"
		lookupTest lookup "hello"
		selectTest
			singleTest select "hello"
			severalTest select "hello.hello"
			complexTest select "
				hello.["world"]
			"
		keysSearchTest
			simple keysSearch "$hello"
		keysTest
			simple keys "hello.hello"
		callTest
			simple call "
				hello "hi"
			"
		endOfLineTest
			unix
				shouldMatch endOfLine
					. 10
				shouldNotMatch endOfLine "hello"
			windows 
				shouldMatch endOfLine
					. 13
					. 10
				shouldNotMatch endOfLine "hello"
		whitespaceTest
			shouldMatch whitespace "					 "
			shouldNotMatch whitespace "			kj	"
character
	documentation "Matches one character."
	char|rule
		condition
			parser|if
				condition not zero parser
				then
					|if
						condition equal
							. first parser
							. char
						then
							|
								parsed first parser
								text slice
									array parser
									start 2
		result
			char|char
characterSet
	documentation "Matches one character in a set."
	chars|rule
		condition
			parser|if
				condition not zero parser
				then
					|if
						condition contains
							value first parser
							array chars
						then
							|
								parsed first parser
								text slice
									array parser
									start 2
						else
							|0
		result
			char|char
characterExcept
	documentation "Matches one character that is not the provided character."
	chars|rule
		condition
			parser|if
				condition not zero parser
				then
					|if
						condition not contains
							value first parser
							array chars
						then
							|
								parsed first parser
								text slice
									array parser
									start 2
		result
			char|char
stringRule
	documentation "Matches the provided sequence of characters."
	string|sequence apply
		array string
		function
			char|character char
oneOrMore
	documentation "Matches one or more times."
	status "untested"
	rule|
		parser|
			loop zeroOrMore rule
			loopResult loop parser
			current if
				condition not zero loopResult
				then
					|if
						condition not zero loopResult.parsed
						then
							|loopResult
zeroOrMore
	documentation "Matches zero or more times."
	rule|
		parser|
			text parser
			parsed while
				condition
					|not zero rule text
				function
					|
						ruleResult rule text
						$text ruleResult.text
						current ruleResult.parsed
sequence
	documentation "Matches a sequence of rules."
	rules|
		parser|
			text parser
			allMatched 1
			applied apply
				array rules
				function
					rule|
						ruleResult rule text
						current if
							condition hasKey
								map ruleResult
								key "parsed"
							then
								|
									$text ruleResult.text
									current ruleResult.parsed
							else
								|
									$allMatched 0
									current 0
			current if
				condition allMatched
				then
					|
						parsed applied
						text text
prePost
	documentation "Matches a rule and throws away the results of a preceding and a following rule."
	arg|
		parser|
			preResult arg.pre parser
			current if
				condition not zero preResult
				then
					|
						ruleResult arg.rule preResult.text
						current if
							condition not zero ruleResult
							then
								|
									postResult arg.post ruleResult.text
									current if
										condition not zero postResult
										then
											|
												parsed ruleResult.parsed
												text postResult.text
alternatives
	documentation "Matches one of several alternative rules."
	alts|
		parser|
			parsed 0
			text parser
			matched 0
			. apply
				array alts
				condition
					alt|
						applied alt parser
						current if
							condition hasKey
								map applied
								key "parsed"
							then
								|
									$parsed applied.parsed
									$text applied.text
									$matched 1
									current 0
							else
								|1
				function
					|0
			current if
				condition matched
				then
					|
						parsed parsed
						text text
nTimes
	documentation "Matches a rule n times"
	arg|
		parser|
			text parser
			allMatched 1
			applied apply
				array range arg.n
				condition
					|if
						condition not hasKey
							map arg.rule text
							key "parsed"
						then
							|
								$allMatched 0
								current 0
						else
							|1
				function
					|
						ruleResult rule
						$text ruleResult.text
						current ruleResult.parsed
			current if
				condition allMatched
				then
					|
						parsed applied
						text text
rule
	documentation "A rule returns the result in 'result' or an empty map, if the rule did not match."
	arg|
		parser|
			map arg.condition parser
			stuff if
				condition hasKey
					map map
					key "parsed"
				then
					|
						parsed arg.result map.parsed
						text map.text
			current stuff
optional
	subRule|
		parser|
			subRuleResult subRule parser
			current if
				condition hasKey
					map subRuleResult
					key "parsed"
				then
					|subRuleResult
				else
					|
						text parser
						parsed 0