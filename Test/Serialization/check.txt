"|
	current=library.map.merge
		parent
		=
			"AssignedToCurrent"
	scoping=
		test=
			scopingValue="right"
			|scopingValue
	scopingValue="wrong"
	scopingTest=scoping.test
	lexicalScoping=scopingTest *
	unicodeText="äaba"
	parent.parent.testSubDir.x=*
	persistantDeleteTest=testSubDir.x
	parent.parent.testSubDir.x=
		a="b"
		x=
			x="hello"
			y="world"
	integerHashTest=
		[2]="correct hash content"
		hashTestData=
			[*]=
				[*]=*
		hashTest=[hashTestData]
	negativeInteger=100
	negativeInteger.x="hello"
	integerIncrementTest=5
	integerIncrementTest.[*]=integerIncrementTest
	integerDecrementTest=5
	integerDecrementTest=integerDecrementTest.[*]
	persistenceTest=testSubDir
	literalEscapeTest=
		"asdf"
		"asdf"
		''"as"'df"''
		'''"as"''df"'''
		'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
	"ImpliedAutokey"
	"Autokey"
	commandLineArguments=arg
	aMap=
		a="a"
	[aMap]="Object"
	["normal symbol"]="NormalSymbol"
	lookupSymbol="LookupSymbol"
	["long key symbol"]="LookupExtendedSymbol"
	lookedUpMap=[aMap]
	lookedUpNormalSymbol=["normal symbol"]
	lookedUpSymbol=lookupSymbol
	lookedUpLongSymbol=["long key symbol"]
	object=
		a="default"
		autoSearch="default"
		b=*
		SetA=
			|
				parent.parent.a="c"
				parent.parent.autoSearch="changed"
		SetB=
			|
				parent.parent.b.[1]=arg.value
				current="changed"
		x=
			a="b"
			c="d"
		=
			|
				current.a="b"
	a="default"
	b=*
	aSet=object.SetA *
	bSet=object.SetB
		value=
			x=7
			z=1
	ReturnEverything=
		|
			current=arg
	everythingReturned=ReturnEverything
		"a"
		"b"
		"c"
	variableAsArgument=ReturnEverything
		"x"
		"y"
		"z"
	ReturnFunction=
		|
			current=
				|
					current=
						1
						2
						3
	SetCurrent=
		|
			current=
				arg=arg
				x=arg.symbol
			current=x
	thisSet=SetCurrent
		symbol="haha"
	FirstLevel=
		|
			SecondLevel arg
	SecondLevel=
		|arg
	argTest=FirstLevel
		a="z"
	TestClass=MetaTest.TestClass
	TestClass.NestedClass.field=5
	nestedClassTest=TestClass.NestedClass.field
	testClass=TestClass *
	testClass.floatValue=3
	testClass.doubleValue=4
	testClass.decimalValue=5
	TestClass.boolTest=1
	boolTest=TestClass.boolTest
	MemberTest=MetaTest.MemberTest
	memberTest=MemberTest *
	MemberTest.classField="a"
	memberTest.instanceField="b"
	MemberTest.ClassProperty.set
		memberTest.InstanceProperty.get *
	classPropertyValue=MemberTest.ClassProperty.get *
	memberTest.InstanceProperty.set
		MemberTest.ClassProperty.get *
	instancePropertyValue=memberTest.InstanceProperty.get *
	interceptedSymbol="/hello/"
	positionalNoConversion=MetaTest.PositionalNoConversion
		"m"
		"n"
		"o"
	positionalNoConversionConcatenated=positionalNoConversion.Concatenate
		"r"
		"s"
		"t"
	namedNoConversion=MetaTest.NamedNoConversion
		=
			"m"
			y="n"
	namedNoConversionConcatenated=namedNoConversion.Concatenate
		=
			c="t"
			"r"
	indexerNoConversion=MetaTest.IndexerNoConversion *
	indexerNoConversion.Item.set
		"abc"
		"hihi"
	indexerNoConversionIndexed=indexerNoConversion.Item.get
		"abc"
	interceptedSymbolTwo=1
	k="hello"
	xyz="w"
	literalFunction=
		|5
	literalFunctionResult=literalFunction *
	someFunction=
		|
			current="simple function this"
	callFunction=
		|someFunction
	callFunctionResult=callFunction *
	delayedFunction=
		|
			|
				x="y"
	delayedFunctionResult=delayedFunction *
	value="xyz"
	selectionFunction=
		|value
	selectionFunctionResult=selectionFunction *
	upperLevel="unchanged"
	SetUpperLevel=
		|
			parent.parent.upperLevel=arg
	ChangeUpperLevel=
		|
			SetUpperLevel "changed"
	ChangeUpperLevel *
	staticEventChanged=*
	ChangeStaticEvent=
		|
			parent.parent.staticEventChanged=arg
	TestClass.staticEvent.add
		=
			|
				ChangeStaticEvent 1
				current=arg.[1]
	staticEvent=TestClass.staticEvent
	TestClass.TakeDelegate
		=
			|arg.[1]
	resultFromDelegate=TestClass.GetResultFromDelegate *
	staticEventResult=TestClass.staticEvent
		testClass
	instanceEventChanged=*
	testClass.instanceEvent.add
		=
			|
				parent.parent.parent.instanceEventChanged=1
				current=arg.[1]
	instanceEvent=testClass.instanceEvent
	instanceEventResult=testClass.instanceEvent
		5
	one=1
	two=2
	firstIf="unchanged"
	secondIf="unchanged"
	firstIfCondition=library.map.equal
		1
		one
	firstIfBranches=
		=
			|"then"
		[*]=
			|"else"
	firstIf=firstIfBranches.[firstIfCondition] *
	bigNumber=50020202029029233344
	secondSwitch="unchanged"
	secondSwitchCases=
		"one"
		"two"
		"three"
	secondSwitch=secondSwitchCases.[3]
	emptyMap=*
	emptyFunction=
		|
			x="hello"
	emptyFunctionResult=emptyFunction *
	font=["System.Drawing"].Font
		"Courier New"
		10
	decimalTest=5
	fractionTest=40
	stringTest="hello"
	stringTest.[6]=stringTest.[1]
	helloh="hi"
	stringStrategyHashTest=[stringTest]
	x=
		aLongText="
			hello world!
			hello!
			"
	arrayList=mscorlib.ArrayList *
	arrayList.Add
		"hello"
	arrayListResult=arrayList.Item.get
		*
	textBox=["System.Windows.Forms"].TextBox *
	textBox.Text.set
		"
			Alle meine Entchen,
			schwimmen auf dem See,
			schwimmen auf dem See,
			Köpfchen in das Wasser,
			Schwaenzchen in die Hoeh."
	lines=textBox.Lines.get *
	alleMeineText=lines.[1]
	lines.[5]="bwuhahaha"
	tabText="			hello"
	escapedText="'#'n'''t"
	whileCounter=*
	loop=
		|
			whileDecision=library.logic.not library.map.equal
				arg
				10
			whileBranches=
				=
					|loop library.math.add
						arg
						1
				[*]=
					|arg
			current=whileBranches.[whileDecision] arg
	whileCounter=loop 3
	returnInMap=
		|
			result=arg
	literalAsArgument=returnInMap 1
	returnFunction=
		|
			|"functionResult"
	returnArg=
		|arg
	myArg=
		|
			hello="world"
	funcReturnTest=returnArg myArg *
	documentedFunction=
		doc="This function returns #hello ."
		|"hello"
	docFunctionResult=documentedFunction *
"
