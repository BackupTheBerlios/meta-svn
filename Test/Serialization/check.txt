"|
	current=local.map.merge
		parent
		=
			"AssignedToCurrent"
	scoping=
		test=
			scopingValue="right"
			|scopingValue
	scopingValue="wrong"
	scopingTest=scoping.test
	lexicalScoping=scopingTest *
	unicodeText="äaba"
	parent.parent.testSubDir.x=*
	persistantDeleteTest=testSubDir.x
	parent.parent.testSubDir.x=
		a="b"
		x=
			x="hello"
			y="world"
	integerHashTest=
		[2]="correct hash content"
		hashTestData=
			[*]=
				[*]=*
		hashTest=[hashTestData]
	negativeInteger=100
	negativeInteger.x="hello"
	integerIncrementTest=5
	integerIncrementTest.[*]=integerIncrementTest
	integerDecrementTest=5
	integerDecrementTest=integerDecrementTest.[*]
	persistenceTest=testSubDir
	literalEscapeTest=
		"asdf"
		"asdf"
		''"as"'df"''
		'''"as"''df"'''
		'''''''''''''''''"as"''''''''''''''''df"'''''''''''''''''
	"ImpliedAutokey"
	"Autokey"
	commandLineArguments=arg
	aMap=
		a="a"
	[aMap]="Object"
	["normal symbol"]="NormalSymbol"
	lookupSymbol="LookupSymbol"
	["long key symbol"]="LookupExtendedSymbol"
	lookedUpMap=[aMap]
	lookedUpNormalSymbol=["normal symbol"]
	lookedUpSymbol=lookupSymbol
	lookedUpLongSymbol=["long key symbol"]
	object=
		a="default"
		autoSearch="default"
		b=*
		SetA=
			|
				parent.parent.a="c"
				parent.parent.autoSearch="changed"
		SetB=
			|
				parent.parent.b.[1]=arg.value
				current="changed"
		x=
			a="b"
			c="d"
		=
			|
				current.a="b"
	a="default"
	b=*
	aSet=object.SetA *
	bSet=object.SetB
		value=
			x=7
			z=1
	scopeTest="default"
	scopeFunction=
		inScope="right"
		|
			parent.parent.scopeTest=inScope
	inScope="wrong"
	scopeFunction *
	scopeFromFunctionData="right"
	scopeFunctionFunction=
		scopeFromFunctionData="wrong"
		|
			|scopeFromFunctionData
	scopeFromFunction=scopeFunctionFunction *
	scopeFromFunctionTest=scopeFromFunction *
	ReturnEverything=
		|
			current=arg
	everythingReturned=ReturnEverything
		"a"
		"b"
		"c"
	variableAsArgument=ReturnEverything
		"x"
		"y"
		"z"
	ReturnFunction=
		|
			current=
				|
					current=
						1
						2
						3
	SetCurrent=
		|
			current=
				arg=arg
				x=arg.symbol
			current=x
	thisSet=SetCurrent
		symbol="haha"
	FirstLevel=
		|
			SecondLevel arg
	SecondLevel=
		|arg
	argTest=FirstLevel
		a="z"
	TestClass=MetaTest.testClasses.TestClass
	TestClass.NestedClass.field=5
	nestedClassTest=TestClass.NestedClass.field
	testClass=TestClass *
	testClass.floatValue=3
	testClass.doubleValue=4
	testClass.decimalValue=5
	TestClass.boolTest=1
	boolTest=TestClass.boolTest
	strongNameTest=[
		version="2.0.0.0"
		publicKeyToken="b77a5c561934e089"
		culture="Neutral"
		name="mscorlib"
	].System.Int32
	MemberTest=MetaTest.testClasses.MemberTest
	memberTest=MemberTest *
	stringOverload=MemberTest.OverloadedMethod.[
		mscorlib.System.String
	] "hello"
	integerOverload=MemberTest.OverloadedMethod.[
		mscorlib.System.Int32
	] 5
	memberTestOverload=MemberTest.OverloadedMethod.[
		MetaTest.testClasses.MemberTest
		mscorlib.System.Int32
	]
		memberTest
		3247
	memberTestOverload=MemberTest.OverloadedMethod.[
		MetaTest.testClasses.MemberTest
		mscorlib.System.Int32
	]
		memberTest
		3247
	MemberTest.classField="a"
	memberTest.instanceField="b"
	MemberTest.ClassProperty.set memberTest.InstanceProperty.get *
	classPropertyValue=MemberTest.ClassProperty.get *
	memberTest.InstanceProperty.set MemberTest.ClassProperty.get *
	instancePropertyValue=memberTest.InstanceProperty.get *
	interceptedSymbol="/hello/"
	positionalNoConversion=MetaTest.testClasses.PositionalNoConversion
		"m"
		"n"
		"o"
	positionalNoConversionConcatenated=positionalNoConversion.Concatenate
		"r"
		"s"
		"t"
	namedNoConversion=MetaTest.testClasses.NamedNoConversion
		"m"
		y="n"
	namedNoConversionConcatenated=namedNoConversion.Concatenate
		c="t"
		"r"
	indexerNoConversion=MetaTest.testClasses.IndexerNoConversion *
	indexerNoConversion.Item.set
		"abc"
		"hihi"
	indexerNoConversionIndexed=indexerNoConversion.Item.get "abc"
	interceptedSymbolTwo=1
	k="hello"
	xyz="w"
	literalFunction=
		|5
	literalFunctionResult=literalFunction *
	someFunction=
		|
			current="simple function this"
	callFunction=
		|someFunction
	callFunctionResult=callFunction *
	delayedFunction=
		|
			|
				x="y"
	delayedFunctionResult=delayedFunction *
	value="xyz"
	selectionFunction=
		|value
	selectionFunctionResult=selectionFunction *
	upperLevel="unchanged"
	SetUpperLevel=
		|
			parent.parent.upperLevel=arg
	ChangeUpperLevel=
		|
			SetUpperLevel "changed"
	ChangeUpperLevel *
	staticEventChanged=*
	ChangeStaticEvent=
		|
			parent.parent.staticEventChanged=arg
	TestClass.staticEvent.add
		|
			ChangeStaticEvent 1
			current=arg.[1]
	staticEvent=TestClass.staticEvent
	TestClass.TakeDelegate
		|arg.[1]
	resultFromDelegate=TestClass.GetResultFromDelegate *
	staticEventResult=TestClass.staticEvent testClass
	instanceEventChanged=*
	testClass.instanceEvent.add
		|
			parent.parent.parent.instanceEventChanged=1
			current=arg.[1]
	instanceEvent=testClass.instanceEvent
	instanceEventResult=testClass.instanceEvent 5
	one=1
	two=2
	firstIf="unchanged"
	secondIf="unchanged"
	firstIfCondition=local.map.equal
		1
		one
	firstIfBranches=
		=
			|"then"
		[*]=
			|"else"
	firstIf=firstIfBranches.[firstIfCondition] *
	bigNumber=50020202
	secondSwitch="unchanged"
	secondSwitchCases=
		"one"
		"two"
		"three"
	secondSwitch=secondSwitchCases.[3]
	emptyMap=*
	emptyFunction=
		|
			x="hello"
	emptyFunctionResult=emptyFunction *
	font=["System.Drawing"].System.Drawing.Font.Font.[
		mscorlib.System.String
		mscorlib.System.Single
	]
		"Courier New"
		10
	decimalTest=5
	fractionTest=40
	stringTest="hello"
	stringTest.[6]=stringTest.[1]
	helloh="hi"
	stringStrategyHashTest=[stringTest]
	x=
		aLongText="
			hello world!
			hello!
			"
	arrayList=mscorlib.System.Collections.ArrayList.ArrayList.[*] *
	arrayList.Add "hello"
	arrayListResult=arrayList.Item.get *
	textBox=["System.Windows.Forms"].System.Windows.Forms.TextBox *
	textBox.Text.set "
		Alle meine Entchen,
		schwimmen auf dem See,
		schwimmen auf dem See,
		Köpfchen in das Wasser,
		Schwaenzchen in die Hoeh."
	lines=textBox.Lines.get *
	alleMeineText=lines.GetValue.[
		mscorlib.System.Int32
	] 1
	lines.[5]="bwuhahaha"
	tabText="			hello"
	escapedText="'#'n'''t"
	whileCounter=*
	loop=
		|
			whileDecision=local.logic.not local.map.equal
				arg
				10
			whileBranches=
				=
					|loop local.math.add
						arg
						1
				[*]=
					|arg
			current=whileBranches.[whileDecision] arg
	whileCounter=loop 3
	returnInMap=
		|
			result=arg
	literalAsArgument=returnInMap 1
	returnFunction=
		|
			|"functionResult"
	returnArg=
		|arg
	myArg=
		|
			hello="world"
	funcReturnTest=returnArg myArg *
	documentedFunction=
		doc="This function returns #hello ."
		|"hello"
	docFunctionResult=documentedFunction *
"
