//	Meta is a programming language.
//	Copyright (C) 2004 Christian Staudenmeyer <christianstaudenmeyer@web.de>
//
//	This program is free software; you can redistribute it and/or
//	modify it under the terms of the GNU General Public License version 2
//	as published by the Free Software Foundation.
//
//	This program is distributed in the hope that it will be useful,
//	but WITHOUT ANY WARRANTY; without even the implied warranty of
//	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
//	GNU General Public License for more details.
//
//	You should have received a copy of the GNU General Public License
//	along with this program; if not, write to the Free Software
//	Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
this=map.Merge
	parent
	=
		"AssignedToCurrent"
unicodeText="äaba"
this=map.Merge
	parent
	programFlow
	logic
	map
	math
//run "hello"
interpreter.line:"5"
nestedClassTest=interpreter.line
applyMethod=!Add
	arg.value
	"1"
applyTest=Apply
	applyMethod
	=
		"1"
		"2"
		"3"
ifTest=If
	Equal
		"1"
		"1"
	=
		#"it is true"
	=
		#"it is false"
trimStartTest=TrimStart
	"					hello"
	"\\t"
form=Init
	System.Windows.Forms.Form""
	=
		Text="hello"
"ImpliedAutokey"
="Autokey"
gacTest=System.Collections
lazyGACTest=Microsoft.CSharp
metaLibTest=metaLib
commandLineArguments=arg
libraryAssemblyTest=testClasses
	//	asdfasdf	fff
//thisIsInAComment#
	//  still comment
// some more comment
aMap=
	["a"]="a"
[aMap]="Object"
["normal symbol"]="NormalSymbol"
lookupSymbol="LookupSymbol"
["long key symbol"]="LookupExtendedSymbol"
lookedUpMap=[aMap]
lookedUpNormalSymbol=["normal symbol"]
lookedUpSymbol=lookupSymbol
lookedUpLongSymbol=["long key symbol"]
object=
	a="default"
	autoSearch="default"
	b=""
	SetA=!
		a:"c"
		autoSearch:"changed"
	SetB=
		#
			b.1:arg.value
			this="changed"
	x=
		a="b"
		c="d"
	=
		#
			this.a="b"
a="default"
b=""
aSet=object.SetA""
bSet=object.SetB
	value=
		x="7"
		z="1"
ReturnEverything=
	#
		this=arg
everythingReturned=ReturnEverything
	"a"
	"b"
	"c"
variableAsArgument=ReturnEverything
	"x"
	"y"
	"z"
ReturnFunction=
	#
		this=
			#
				this=
					"1"
					"2"
					"3"
SetCurrent=
	#
		this=
			arg=arg
			x=arg.symbol
		this=x
thisSet=SetCurrent
	symbol="haha"
FirstLevel=
	#
		SecondLevel arg
SecondLevel=
	#arg
argTest=FirstLevel
	a="z"
concatenate=map.Join
	"x"
	"yz"
this=map.Merge
	parent
	testClasses
testClass=TestClass""
testClass.floatValue=
	iNumerator="1"
	iDenominator="3"
testClass.doubleValue=
	iNumerator="1"
	iDenominator="3"
testClass.decimalValue=
	iNumerator="1"
	iDenominator="3"
TestClass.boolTest="1"
boolTest=TestClass.boolTest
memberTest=MemberTest""
MemberTest.classField="a"
memberTest.instanceField="b"
MemberTest.ClassProperty=memberTest.InstanceProperty
memberTest.InstanceProperty=MemberTest.ClassProperty
interceptedSymbol="/hello/"
positionalNoConversion=PositionalNoConversion
	"m"
	"n"
	"o"
positionalNoConversionConcatenated=positionalNoConversion.Concatenate
	"r"
	"s"
	"t"
namedNoConversion=NamedNoConversion
	"m"
	y="n"
namedNoConversionConcatenated=namedNoConversion.Concatenate
	c="t"
	"r"
indexerNoConversion=IndexerNoConversion""
indexerNoConversion.abc="hihi"
indexerNoConversionIndexed=indexerNoConversion.abc
interceptedSymbol2="1"
k="hello"
xyz="w"
literalFunction=
	#"5"
literalFunctionResult=literalFunction""
function=
	#
		this="simple function this"
callFunction=
	#function
callFunctionResult=callFunction""
delayedFunction=
	#
		#
			x="y"
delayedFunctionResult=delayedFunction ""
value="xyz"
selectionFunction=
	#value
selectionFunctionResult=selectionFunction ""
bigInteger="89383838383832839123497123047217340712340720347072304702340720347"
upperLevel="unchanged"
ChangeUpperLevel=
	#
		upperLevel:"changed"
ChangeUpperLevel""
staticEventChanged="0"
TestClass.staticEvent=
	#
		staticEventChanged:"1"
		this=arg.1
staticEvent=TestClass.staticEvent
TestClass.TakeDelegate
	#"resultFromDelegate"
resultFromDelegate=TestClass.GetResultFromDelegate""
staticEventResult=TestClass.staticEvent testClass
instanceEventChanged="0"
testClass.instanceEvent=
	#
		instanceEventChanged:"1"
		this=arg.1
instanceEvent=testClass.instanceEvent
instanceEventResult=testClass.instanceEvent
	"5"
one="1"
two="2"
firstIf="unchanged"
secondIf="unchanged"
firstIfCondition=Equal
	"1"
	one
firstIfBranches=
	1=
		#"then"
	0=
		#"else"
firstIf=firstIfBranches.[firstIfCondition]""
bigNumber="50020202029029233344"
secondSwitch="unchanged"
secondSwitchCases=
	1="one"
	2="two"
	3="three"
secondSwitch=secondSwitchCases.3
emptyMap=""
emptyFunction=
	#
		x="hello"
emptyFunctionResult=emptyFunction""
font=System.Drawing.Font
	"Courier New"
	"10"
stringTest="hello"
stringTest.6=stringTest.1
helloh="hi"
stringStrategyHashTest=[stringTest]
x=
	aLongText="
		hello word!
		hello!
		"
ored=BitwiseOr
	"20"
	System.Windows.Forms.Keys.Tab
arrayList=System.Collections.ArrayList""
arrayList.Add "hello"
arrayListResult=arrayList.0
textBox=System.Windows.Forms.TextBox""
textBox.Text="
	Alle meine Entchen,
	schwimmen auf dem See,
	schwimmen auf dem See,
	Köpfchen in das Wasser,
	Schwaenzchen in die Hoeh.
	"
lines=textBox.Lines
alleMeineText=lines.1
lines.4="bwuhahaha"
character="\a"
tab="\\t"
backslash="\\\"
endline="\\n"
tabText="			hello"
escapedText="\'\n\\\t"
whileCounter=""
loop=
	#
		whileDecision=Smaller
			arg
			"10"
		whileBranches=
			1=
				#loop Add
					arg
					"1"
				 
			0=
				#arg
		this=whileBranches.[whileDecision] arg
whileCounter=loop "3"

	
returnInMap=
					
	#
		result=arg
literalAsArgument=returnInMap	 "1"				   
returnFunction=
	#
		#"functionResult"
returnArg=
	#arg
myArg=
	#
		hello="world"
funcReturnTest=returnArg myArg""
documentedFunction=
	doc="This function returns 'hello ."
	#"hello"
docFunctionResult=documentedFunction""